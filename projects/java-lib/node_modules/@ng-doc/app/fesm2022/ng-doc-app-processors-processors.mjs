import { NgDocBlockquoteComponent, NgDocIconComponent, NgDocTooltipDirective } from '@ng-doc/ui-kit';
import { NgDocCodeComponent } from '@ng-doc/app/components/code';
import { NgDocDemoComponent } from '@ng-doc/app/components/demo';
import { NgDocDemoPaneComponent } from '@ng-doc/app/components/demo-pane';
import { NgDocPageLinkComponent } from '@ng-doc/app/components/page-link';
import { NgDocPlaygroundComponent } from '@ng-doc/app/components/playground';
import { isPresent } from '@ng-doc/core';
import * as i0 from '@angular/core';
import { Renderer2, ElementRef, Component, ChangeDetectionStrategy, Input, ViewChild } from '@angular/core';
import { NgDocTabsComponent } from '@ng-doc/app/components/tabs';

const blockquoteProcessor = {
    component: NgDocBlockquoteComponent,
    selector: 'ng-doc-blockquote',
    extractOptions: (element) => ({
        content: [Array.from(element.childNodes)],
        inputs: {
            type: element.getAttribute('type') || 'default',
        },
    }),
};

const codeProcessor = {
    component: NgDocCodeComponent,
    selector: 'pre code',
    nodeToReplace: (element) => element.closest('pre') ?? element,
    extractOptions: (element) => ({
        inputs: {
            copyButton: element.getAttribute('copyButton') !== 'false',
            name: element.getAttribute('name') || undefined,
            icon: element.getAttribute('icon') || undefined,
            lineNumbers: element.getAttribute('lineNumbers') !== 'false',
        },
        content: [[element.closest('pre') ?? element]],
    }),
};

const demoProcessor = {
    component: NgDocDemoComponent,
    selector: 'ng-doc-demo',
    extractOptions: (element) => ({
        inputs: {
            componentName: element.getAttribute('componentName') || undefined,
            options: JSON.parse(element.querySelector('#options')?.textContent ?? '') || {},
        },
    }),
};

const demoPaneProcessor = {
    component: NgDocDemoPaneComponent,
    selector: 'ng-doc-demo-pane',
    extractOptions: (element) => ({
        inputs: {
            componentName: element.getAttribute('componentName') || undefined,
            options: JSON.parse(element.querySelector('#options')?.textContent ?? '') || {},
        },
    }),
};

const iconProcessor = {
    component: NgDocIconComponent,
    selector: 'ng-doc-icon',
    extractOptions: (element) => ({
        inputs: {
            icon: element.getAttribute('icon') ?? '',
            size: Number(element.getAttribute('size')) || 16,
        },
    }),
};

const linkProcessor = {
    component: NgDocPageLinkComponent,
    selector: 'a',
    extractOptions: (element) => ({
        inputs: {
            href: element.getAttribute('href') ?? '',
            classes: element.getAttribute('class') ?? '',
        },
        content: [Array.from(element.childNodes)],
    }),
};

const playgroundProcessor = {
    component: NgDocPlaygroundComponent,
    selector: 'ng-doc-playground',
    extractOptions: (element) => ({
        inputs: {
            id: element.getAttribute('id') || undefined,
            properties: JSON.parse(element.querySelector('#data')?.textContent?.replace(/\n/g, '\\n') ?? '') ||
                undefined,
            pipeName: element.querySelector('#pipeName')?.textContent || undefined,
            selectors: (element.querySelector('#selectors')?.textContent || '')
                .split(',')
                .map((selector) => selector.trim())
                .filter(isPresent),
            options: JSON.parse(element.querySelector('#options')?.textContent ?? '') || {},
        },
    }),
};

const tabsProcessor = {
    component: NgDocTabsComponent,
    selector: 'ng-doc-tab',
    nodeToReplace: (element, injector) => {
        const renderer = injector.get(Renderer2);
        const anchor = renderer.createElement('div');
        return element.parentNode?.insertBefore(anchor, element) ?? element;
    },
    extractOptions: (element, root) => {
        const group = element.getAttribute('group') ?? '';
        const tabs = Array.from(root.querySelectorAll(`ng-doc-tab[group="${group}"]`));
        const mappedTabs = tabs.map((tab) => ({
            title: tab.getAttribute('name') ?? '',
            content: tab,
            icon: tab.getAttribute('icon') || undefined,
            active: tab.hasAttribute('active'),
        }));
        tabs.forEach((tab) => tab.remove());
        return {
            inputs: {
                tabs: mappedTabs,
            },
        };
    },
};

class NgDocTooltipWrapperComponent {
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.tooltipElement = null;
    }
    ngAfterViewInit() {
        if (this.contentProjection) {
            const element = this.contentProjection.nativeElement.querySelector('[ngDocTooltip]');
            this.tooltipElement = element instanceof HTMLElement ? element : null;
            this.changeDetectorRef.detectChanges();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocTooltipWrapperComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.0", type: NgDocTooltipWrapperComponent, isStandalone: true, selector: "ng-doc-tooltip-wrapper", inputs: { content: "content" }, viewQueries: [{ propertyName: "contentProjection", first: true, predicate: ["contentProjection"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: `
		<div
			class="content-projection"
			[ngDocTooltip]="content ?? ''"
			[displayOrigin]="tooltipElement ?? contentProjection"
			[pointerOrigin]="tooltipElement ?? contentProjection"
			#contentProjection>
			<ng-content></ng-content>
		</div>
	`, isInline: true, styles: [".content-projection{display:unset}\n"], dependencies: [{ kind: "directive", type: NgDocTooltipDirective, selector: "[ngDocTooltip]", inputs: ["ngDocTooltip", "delay", "displayOrigin", "pointerOrigin", "positions", "canOpen", "panelClass", "minHeight", "maxHeight", "height", "minWidth", "maxWidth", "width"], outputs: ["beforeOpen", "afterOpen", "beforeClose", "afterClose"], exportAs: ["ngDocTooltip"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocTooltipWrapperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ng-doc-tooltip-wrapper', template: `
		<div
			class="content-projection"
			[ngDocTooltip]="content ?? ''"
			[displayOrigin]="tooltipElement ?? contentProjection"
			[pointerOrigin]="tooltipElement ?? contentProjection"
			#contentProjection>
			<ng-content></ng-content>
		</div>
	`, changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, imports: [NgDocTooltipDirective], styles: [".content-projection{display:unset}\n"] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }], propDecorators: { content: [{
                type: Input
            }], contentProjection: [{
                type: ViewChild,
                args: ['contentProjection', { read: ElementRef, static: true }]
            }] } });
const tooltipProcessor = {
    component: NgDocTooltipWrapperComponent,
    selector: '[ngDocTooltip]',
    extractOptions: (element) => ({
        inputs: {
            content: element.getAttribute('ngDocTooltip') ?? '',
        },
        content: [[element.cloneNode(true)]],
    }),
};

/**
 * Generated bundle index. Do not edit.
 */

export { blockquoteProcessor, codeProcessor, demoPaneProcessor, demoProcessor, iconProcessor, linkProcessor, playgroundProcessor, tabsProcessor, tooltipProcessor };
//# sourceMappingURL=ng-doc-app-processors-processors.mjs.map
