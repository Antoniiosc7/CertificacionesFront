import { __decorate, __metadata } from 'tslib';
import * as i1 from '@angular/cdk/layout';
import { Breakpoints, BreakpointObserver } from '@angular/cdk/layout';
import { DOCUMENT } from '@angular/common';
import * as i0 from '@angular/core';
import { Injectable, Inject } from '@angular/core';
import * as i2 from '@angular/router';
import { NavigationEnd, Router } from '@angular/router';
import * as i3 from '@ng-doc/ui-kit/services/scroll';
import { NgDocScrollService } from '@ng-doc/ui-kit/services/scroll';
import { untilDestroyed, UntilDestroy } from '@ngneat/until-destroy';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { pluck, distinctUntilChanged, filter, debounceTime } from 'rxjs/operators';

/**
 * Service for sidebar, it can be used to hide/show sidebar or to check if sidebar is collapsable.
 */
let NgDocSidebarService = class NgDocSidebarService {
    constructor(document, breakpointObserver, router, scroll) {
        this.document = document;
        this.breakpointObserver = breakpointObserver;
        this.router = router;
        this.scroll = scroll;
        this.breakpoints = [Breakpoints.XSmall, Breakpoints.Small];
        this.expanded = new BehaviorSubject(true);
        this.observer = this.breakpointObserver
            .observe(this.breakpoints)
            .pipe(pluck('matches'), distinctUntilChanged(), untilDestroyed(this));
        combineLatest([this.router.events, this.isMobileMode()])
            .pipe(filter(([event, isMobileMode]) => event instanceof NavigationEnd && this.expanded.value && isMobileMode), debounceTime(10))
            .subscribe(() => this.hide());
        this.isMobileMode()
            .pipe(untilDestroyed(this))
            .subscribe((isMobileMode) => {
            if (isMobileMode) {
                this.hide();
            }
            else {
                this.show();
                this.scroll.unblock();
            }
        });
    }
    /**
     * Indicates if sidebar is collapsable, based on the screen size.
     */
    isMobileMode() {
        return this.observer;
    }
    /**
     * Indicates if sidebar is visible, based on the show/hide methods.
     */
    isExpanded() {
        return this.expanded.asObservable();
    }
    /**
     * Show sidebar, and block scrolling.
     */
    show() {
        if (!this.expanded.value) {
            this.expanded.next(true);
            this.scroll.block();
        }
    }
    /**
     * Hide sidebar, and unblock scrolling.
     */
    hide() {
        if (this.expanded.value) {
            this.expanded.next(false);
            this.scroll.unblock();
        }
    }
    /**
     * Toggle sidebar visibility.
     */
    toggle() {
        this.expanded.value ? this.hide() : this.show();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocSidebarService, deps: [{ token: DOCUMENT }, { token: i1.BreakpointObserver }, { token: i2.Router }, { token: i3.NgDocScrollService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocSidebarService, providedIn: 'root' }); }
};
NgDocSidebarService = __decorate([
    UntilDestroy(),
    __metadata("design:paramtypes", [Document,
        BreakpointObserver,
        Router,
        NgDocScrollService])
], NgDocSidebarService);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocSidebarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.BreakpointObserver }, { type: i2.Router }, { type: i3.NgDocScrollService }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgDocSidebarService };
//# sourceMappingURL=ng-doc-app-services-sidebar.mjs.map
