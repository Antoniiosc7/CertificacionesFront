import * as i0 from '@angular/core';
import { EventEmitter, inject, ElementRef, ViewContainerRef, Injector, Renderer2, Directive, Input, Output } from '@angular/core';
import { NG_DOC_PAGE_PROCESSOR, NG_DOC_PAGE_CUSTOM_PROCESSOR } from '@ng-doc/app/tokens';
import { asArray, objectKeys } from '@ng-doc/core';

/**
 * Base processor class to create a processor directive that will be used to replace
 * html nodes with an Angular component.
 */
class NgDocPageProcessorDirective {
    constructor() {
        this.html = '';
        this.afterRender = new EventEmitter();
        this.processors = inject(NG_DOC_PAGE_PROCESSOR, { optional: true }) ?? [];
        this.customProcessors = inject(NG_DOC_PAGE_CUSTOM_PROCESSOR, { optional: true }) ??
            [];
        this.elementRef = inject(ElementRef);
        this.viewContainerRef = inject(ViewContainerRef);
        this.injector = inject(Injector);
        this.renderer = inject(Renderer2);
    }
    ngOnChanges({ html }) {
        if (html) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'innerHTML', this.html);
            this.afterRender.emit();
        }
    }
    ngOnInit() {
        asArray(this.processors, this.customProcessors).forEach(this.process.bind(this));
    }
    process(processor) {
        Array.from(this.elementRef.nativeElement.querySelectorAll(processor.selector)).forEach((elementNode) => {
            // check if element node has a parent node because it can be removed by another processor
            if (elementNode.parentNode) {
                const replaceElement = (processor.nodeToReplace && processor.nodeToReplace(elementNode, this.injector)) ??
                    elementNode;
                const options = processor.extractOptions(elementNode, this.elementRef.nativeElement);
                // create component
                const componentRef = this.viewContainerRef.createComponent(processor.component, {
                    projectableNodes: options.content,
                    injector: this.injector,
                });
                // set component options
                if (options.inputs) {
                    objectKeys(options.inputs).forEach((key) => options.inputs && componentRef.setInput(key, options.inputs[key]));
                }
                // replace element node with component node
                replaceElement.parentNode?.replaceChild(componentRef.location.nativeElement, replaceElement);
                componentRef.changeDetectorRef.markForCheck();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocPageProcessorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.0", type: NgDocPageProcessorDirective, isStandalone: true, selector: "[ngDocPageProcessor]", inputs: { html: ["ngDocPageProcessor", "html"] }, outputs: { afterRender: "afterRender" }, host: { attributes: { "ngSkipHydration": "true" } }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocPageProcessorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngDocPageProcessor]',
                    standalone: true,
                    host: { ngSkipHydration: 'true' },
                }]
        }], propDecorators: { html: [{
                type: Input,
                args: [{ required: true, alias: 'ngDocPageProcessor' }]
            }], afterRender: [{
                type: Output
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgDocPageProcessorDirective };
//# sourceMappingURL=ng-doc-app-processors-page-processor.mjs.map
