"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSnippets = processSnippets;
const tslib_1 = require("tslib");
const core_1 = require("@ng-doc/core");
const fs = tslib_1.__importStar(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const parse_snippet_1 = require("../parsers/parse-snippet");
const format_code_1 = require("./format-code");
const get_code_type_from_lang_1 = require("./get-code-type-from-lang");
const snippet = (id) => id
    ? new RegExp(`\\n?\\r?^.*((\\/\\/|<!--|\\/\\*)\\s*)(snippet#${(0, core_1.escapeRegexp)(id)}.*?(?=(-->|\\*\\/)?))\\s*(-->|\\*\\/)?$`, 'gm')
    : new RegExp(`\\n?\\r?^.*((\\/\\/|<!--|\\/\\*)\\s*)(snippet.*?(?=(-->|\\*\\/)?))\\s*(-->|\\*\\/)?$`, 'gm');
/**
 * Process snippets from code
 * @param code - code to process
 * @param basePath - base path to file
 */
function processSnippets(code, basePath) {
    var _a;
    const result = [];
    const endings = new Set();
    const startRegexp = snippet();
    let match;
    // eslint-disable-next-line no-cond-assign
    while ((match = startRegexp.exec(code))) {
        const isHTMLComment = match[2] === '<!--';
        if (((_a = match[3]) === null || _a === void 0 ? void 0 : _a.includes('snippet-from-file=')) && basePath) {
            const config = (0, parse_snippet_1.parseSnippet)(match[3].trim());
            if (config) {
                const { title, lang, icon, opened, fromFile } = config;
                const language = lang || (isHTMLComment ? 'html' : 'ts');
                if (fromFile) {
                    const snippetCode = fs.readFileSync(path_1.default.join(basePath, fromFile), 'utf-8');
                    result.push({
                        title: title !== null && title !== void 0 ? title : path_1.default.basename(fromFile),
                        lang: language,
                        icon,
                        opened,
                        code: (0, format_code_1.formatCode)(removeSnippets(snippetCode), (0, get_code_type_from_lang_1.getCodeTypeFromLang)(language)).trim(),
                    });
                }
            }
        }
        else if (!endings.has(match.index)) {
            const config = (0, parse_snippet_1.parseSnippet)(match[3].trim());
            if (config) {
                const { id, title, lang, icon, opened } = config;
                const endRegexp = snippet(id);
                endRegexp.lastIndex = match.index + match[0].length;
                const matchEnd = endRegexp.exec(code);
                if (matchEnd) {
                    endings.add(matchEnd.index);
                    const snippetCode = code.slice(match.index + match[0].length, matchEnd.index);
                    const language = lang || (isHTMLComment ? 'html' : 'ts');
                    if (snippetCode) {
                        result.push({
                            title,
                            lang: language,
                            icon,
                            opened,
                            code: (0, format_code_1.formatCode)(removeSnippets(snippetCode), (0, get_code_type_from_lang_1.getCodeTypeFromLang)(language)).trim(),
                        });
                    }
                }
            }
        }
    }
    return result;
}
/**
 *
 * @param code
 */
function removeSnippets(code) {
    return code.replace(snippet(), '');
}
//# sourceMappingURL=process-snippets.js.map