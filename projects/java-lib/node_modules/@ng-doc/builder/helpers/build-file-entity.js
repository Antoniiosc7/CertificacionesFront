"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFileEntity = buildFileEntity;
const tslib_1 = require("tslib");
const core_1 = require("@ng-doc/core");
const esbuild = tslib_1.__importStar(require("esbuild"));
const minimatch_1 = require("minimatch");
const path = tslib_1.__importStar(require("path"));
const ts_morph_1 = require("ts-morph");
const engine_1 = require("../engine");
const typescript_1 = require("./typescript");
/**
 * Builds file entity and returns the path to the built file
 * @param sourceFile - source file to build
 * @param tsconfig - path to tsconfig file
 * @param outbase - path to the outbase directory
 */
function buildFileEntity(sourceFile, tsconfig, outbase) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f;
        let code = sourceFile.getFullText();
        const p = path.relative(outbase, sourceFile.getFilePath());
        const outPath = path.join(engine_1.CACHE_PATH, p).replace(/\.ts$/, '.mjs');
        /**
         * Remove `imports`, `providers`, `demos` and `playgrounds` properties from the default export
         * if the file is a page. This is done to prevent compiling the page dependencies
         * that are not needed for the NgDoc builder to work or may cause performance issues.
         */
        if ((0, minimatch_1.minimatch)(p, engine_1.PAGE_PATTERN)) {
            const objectLiteralExpression = (0, typescript_1.getObjectExpressionFromDefault)(sourceFile);
            /**
             * We use regex to remove the properties because ts-morph does it slowly
             */
            if (objectLiteralExpression) {
                code = replaceCodeProperty(code, (_b = (_a = objectLiteralExpression.getProperty('imports')) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : '');
                code = replaceCodeProperty(code, (_d = (_c = objectLiteralExpression.getProperty('providers')) === null || _c === void 0 ? void 0 : _c.getText()) !== null && _d !== void 0 ? _d : '');
                code = replaceCodeProperty(code, (_f = (_e = objectLiteralExpression.getProperty('demos')) === null || _e === void 0 ? void 0 : _e.getText()) !== null && _f !== void 0 ? _f : '');
                code = removePlaygroundTarget(code, objectLiteralExpression);
                if (objectLiteralExpression.getProperty('route')) {
                    const route = objectLiteralExpression.getProperty('route');
                    if (ts_morph_1.Node.isPropertyAssignment(route)) {
                        const routeValue = route.getInitializer();
                        if (ts_morph_1.Node.isObjectLiteralExpression(routeValue)) {
                            routeValue.getProperties().forEach((prop) => {
                                if (ts_morph_1.Node.isPropertyAssignment(prop) && prop.getName() !== 'path') {
                                    code = replaceCodeProperty(code, prop.getText());
                                }
                            });
                        }
                    }
                }
            }
        }
        yield esbuild.build({
            stdin: {
                contents: code,
                resolveDir: path.dirname(p),
                loader: 'ts',
                sourcefile: p,
            },
            tsconfig,
            bundle: true,
            format: 'esm',
            treeShaking: true,
            packages: 'external',
            outbase,
            outfile: outPath,
        });
        // Restore the file from the file system
        yield sourceFile.refreshFromFileSystem();
        return outPath;
    });
}
/**
 *
 * @param code
 * @param objectLiteralExpression
 */
function removePlaygroundTarget(code, objectLiteralExpression) {
    // List of properties that should not be removed
    const keepProperties = ['controls', 'data'];
    const playgrounds = objectLiteralExpression.getProperty('playgrounds');
    if (ts_morph_1.Node.isPropertyAssignment(playgrounds)) {
        const playgroundsValue = playgrounds.getInitializer();
        if (ts_morph_1.Node.isObjectLiteralExpression(playgroundsValue)) {
            playgroundsValue.getProperties().forEach((prop) => {
                if (ts_morph_1.Node.isPropertyAssignment(prop)) {
                    const playground = prop.getInitializer();
                    if (ts_morph_1.Node.isObjectLiteralExpression(playground)) {
                        playground.getProperties().forEach((playgroundProp) => {
                            if (ts_morph_1.Node.isPropertyAssignment(playgroundProp) &&
                                !keepProperties.includes(playgroundProp.getName())) {
                                code = replaceCodeProperty(code, playgroundProp.getText());
                            }
                        });
                    }
                }
            });
        }
    }
    return code;
}
/**
 *
 * @param code
 * @param property
 */
function replaceCodeProperty(code, property) {
    const regex = new RegExp(`${(0, core_1.escapeRegexp)(property)},?`);
    return code.replace(regex, '');
}
//# sourceMappingURL=build-file-entity.js.map