"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildIndexes = buildIndexes;
const tslib_1 = require("tslib");
const orama_1 = require("@orama/orama");
const plugin_parsedoc_1 = require("@orama/plugin-parsedoc");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const import_esm_1 = require("./import-esm");
/**
 *    Builds the indexes for a given content
 * @param config
 */
function buildIndexes(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const pages = [];
        const db = yield (0, orama_1.create)({
            schema: Object.assign({}, plugin_parsedoc_1.defaultHtmlSchema),
        });
        const indexableContent = yield removeNotIndexableContent(config.content);
        yield (0, plugin_parsedoc_1.populate)(db, indexableContent, 'html', {
            transformFn: (node) => transformFn(node),
        });
        let section;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        Object.values(db.data.docs.docs)
            .filter(isIndexable)
            .forEach((doc) => {
            var _a;
            if (doc) {
                if (isHeading(doc)) {
                    section = doc;
                }
                else {
                    pages.push({
                        breadcrumbs: config.breadcrumbs,
                        pageType: config.pageType,
                        title: config.title,
                        section: (_a = section === null || section === void 0 ? void 0 : section.content) !== null && _a !== void 0 ? _a : '',
                        route: config.route,
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        fragment: (section === null || section === void 0 ? void 0 : section.properties) && section.properties['id'],
                        content: doc.content.toString() === '%%API_NAME_ANCHOR%%' ? undefined : doc.content.toString(),
                    });
                }
            }
        });
        return pages;
    });
}
/**
 *
 * @param doc
 */
function isIndexable(doc) {
    var _a;
    return !!((_a = doc === null || doc === void 0 ? void 0 : doc.content) === null || _a === void 0 ? void 0 : _a.trim());
}
/**
 *
 * @param node
 * @param doc
 */
function isHeading(doc) {
    return (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(doc.type) &&
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !!(doc === null || doc === void 0 ? void 0 : doc.properties) &&
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !!doc.properties['id']);
}
/**
 *
 * @param node
 * @param entity
 */
function transformFn(node) {
    switch (node.tag) {
        case 'strong':
        case 'a':
        case 'time':
        case 'span':
        case 'small':
        case 'b':
        case 'p':
        case 'ul':
            return Object.assign(Object.assign({}, node), { raw: `<p>${node.content}</p>` });
        default:
            return node;
    }
}
/**
 *
 * @param html
 */
function removeNotIndexableContent(html) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (0, rxjs_1.firstValueFrom)((0, rxjs_1.from)((0, import_esm_1.importEsm)('@ng-doc/utils')).pipe((0, operators_1.switchMap)((utils) => utils.removeNotIndexableContent(html))));
    });
}
//# sourceMappingURL=build-indexes.js.map