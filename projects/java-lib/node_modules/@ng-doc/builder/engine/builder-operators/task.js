"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.task = task;
exports.taskForMany = taskForMany;
const rxjs_1 = require("rxjs");
const operators_1 = require("../../operators");
/**
 * Task operator that runs the provided operator on each value of the source.
 * It also filters the values if the filter function is provided, shows the progress and handles the errors.
 *
 * The operator will be executed for each value that passes the filter function,
 * and return the values in the same order as they were in the source.
 * @param name - The name of the task (for progress).
 * @param operator - The operator to run on each value of the source.
 * @param filter - The filter function to filter the values of the source.
 */
function task(name, operator, filter) {
    return (source) => {
        return source.pipe((0, operators_1.progress)(name), (0, rxjs_1.mergeMap)((values) => {
            const filtered = filter ? values.filter(filter) : values;
            return (0, operators_1.forkJoinOrEmpty)(filtered.map((v) => (0, rxjs_1.of)(v).pipe(operator)));
        }));
    };
}
/**
 * Task operator that runs the provided operator on the source with all the values.
 * It also filters the values if the filter function is provided, shows the progress and handles the errors.
 *
 * The operator will be executed for each value that passes the filter function,
 * and return the values in the same order as they were in the source.
 * @param name - The name of the task (for progress).
 * @param operator - The operator to run on the source.
 * @param filter - The filter function to filter the values of the source.
 */
function taskForMany(name, operator, filter) {
    return (source) => {
        return source.pipe((0, operators_1.progress)(name), (0, rxjs_1.mergeMap)((values) => {
            const filtered = filter ? values.filter(filter) : values;
            return (0, rxjs_1.of)(filtered).pipe(operator);
        }));
    };
}
//# sourceMappingURL=task.js.map