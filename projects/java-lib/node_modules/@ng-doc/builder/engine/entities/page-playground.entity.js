"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgDocPagePlaygroundEntity = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const rxjs_1 = require("rxjs");
const helpers_1 = require("../../helpers");
const nunjucks_1 = require("../nunjucks");
const entity_1 = require("./abstractions/entity");
const cache_1 = require("./cache");
let NgDocPagePlaygroundEntity = (() => {
    var _a;
    let _classSuper = entity_1.NgDocEntity;
    let _instanceExtraInitializers = [];
    let _get_outputPath_decorators;
    return _a = class NgDocPagePlaygroundEntity extends _classSuper {
            constructor(store, cache, context, parent) {
                super(store, cache, context);
                this.store = (tslib_1.__runInitializers(this, _instanceExtraInitializers), store);
                this.cache = cache;
                this.context = context;
                this.parent = parent;
                this.id = `${this.parent.id}#playground`;
                this.isRoot = false;
                this.metadata = {};
            }
            get rootFiles() {
                return [];
            }
            get buildCandidates() {
                return [this.parent];
            }
            get outputPath() {
                return path_1.default.join(this.parent.folderPath, 'playgrounds.ts');
            }
            build() {
                this.metadata = this.getMetadata();
                const result = (0, nunjucks_1.renderTemplate)('./playgrounds.ts.nunj', {
                    context: {
                        playgroundMetadata: this.metadata,
                        hasImports: this.parent.hasImports,
                        targetImportPath: this.parent.importPath,
                        outFolder: path_1.default.dirname(this.outputPath),
                    },
                });
                return (0, rxjs_1.of)({
                    result,
                    entity: this,
                    toBuilderOutput: (content) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        return ({
                            content,
                            filePath: this.outputPath,
                        });
                    }),
                });
            }
            getMetadata() {
                const page = this.parent.target;
                if (this.parent.objectExpression && page) {
                    this.parent.refreshDependencies();
                    const expression = (0, helpers_1.getPlaygroundsExpression)(this.parent.objectExpression);
                    if (expression) {
                        return (0, helpers_1.getPlaygroundsIds)(expression).reduce((metadata, id) => {
                            var _b, _c, _d;
                            if (expression) {
                                const playground = (0, helpers_1.getPlaygroundById)(expression, id);
                                if (playground) {
                                    metadata[id] = (0, helpers_1.buildPlaygroundMetadata)(id, playground, this.controlsToProperties((_d = (_c = (_b = page.playgrounds) === null || _b === void 0 ? void 0 : _b[id]) === null || _c === void 0 ? void 0 : _c.controls) !== null && _d !== void 0 ? _d : {}));
                                }
                            }
                            return metadata;
                        }, {});
                    }
                }
                return {};
            }
            controlsToProperties(controls) {
                return Object.entries(controls).reduce((properties, [name, value]) => {
                    var _b, _c, _d;
                    properties[name] = {
                        inputName: typeof value === 'string' ? name : (_b = value.alias) !== null && _b !== void 0 ? _b : name,
                        type: typeof value === 'string' ? value : value.type,
                        description: typeof value === 'string' ? undefined : (_c = value.description) !== null && _c !== void 0 ? _c : undefined,
                        options: typeof value === 'string' ? undefined : (_d = value.options) !== null && _d !== void 0 ? _d : undefined,
                        isManual: true,
                    };
                    return properties;
                }, {});
            }
        },
        (() => {
            var _b;
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create((_b = _classSuper[Symbol.metadata]) !== null && _b !== void 0 ? _b : null) : void 0;
            _get_outputPath_decorators = [(0, cache_1.CachedFilesGetter)()];
            tslib_1.__esDecorate(_a, null, _get_outputPath_decorators, { kind: "getter", name: "outputPath", static: false, private: false, access: { has: obj => "outputPath" in obj, get: obj => obj.outputPath }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.NgDocPagePlaygroundEntity = NgDocPagePlaygroundEntity;
//# sourceMappingURL=page-playground.entity.js.map