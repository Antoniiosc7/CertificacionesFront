"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgDocCache = void 0;
const core_1 = require("@ng-doc/core");
const helpers_1 = require("./helpers");
class NgDocCache {
    constructor(enabled) {
        this.enabled = enabled;
    }
    isCacheValid(cls) {
        return this.enabled && (0, helpers_1.isCacheValid)(cls.id, this.createCache(cls));
    }
    cache(cls) {
        if (!this.enabled) {
            return;
        }
        (0, helpers_1.updateCache)(cls.id, this.createCache(cls));
    }
    createCache(cls) {
        return (0, helpers_1.createCache)(undefined, this.getCachedPaths(cls), this.getCachedProperties(cls));
    }
    getCachedPaths(cls) {
        var _a;
        return (0, core_1.asArray)(new Set((0, core_1.asArray)((_a = cls.__cachedFiles) === null || _a === void 0 ? void 0 : _a.values())
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            .map((property) => cls[property])
            .filter(core_1.isPresent)
            .flat()).values());
    }
    getCachedProperties(cls) {
        var _a;
        const cachedProperties = {};
        (0, core_1.asArray)((_a = cls.__cachedProps) === null || _a === void 0 ? void 0 : _a.keys()).forEach((property) => {
            var _a;
            const accessor = (_a = cls.__cachedProps) === null || _a === void 0 ? void 0 : _a.get(property);
            if (accessor) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                cachedProperties[property] = accessor.set(cls[property]);
            }
        });
        return cachedProperties;
    }
}
exports.NgDocCache = NgDocCache;
//# sourceMappingURL=cache.js.map