"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.entityEmitter = entityEmitter;
const core_1 = require("@ng-doc/core");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const helpers_1 = require("../helpers");
const operators_2 = require("../operators");
const variables_1 = require("./variables");
/**
 * Emits new entities if they are added or changed. Also emits destroyed entities if their root files are unlinked.
 * This function not only creates the entities based on the file path, but also creates the child entities recursively
 * if it's can be done.
 * @param store - The entity store.
 * @param cache - The cache instance.
 * @param context - The builder context.
 * @param project - The project instance.
 * @param watcher - The watcher instance.
 */
function entityEmitter(store, cache, context, project, watcher) {
    return (0, rxjs_1.merge)(watcher.onAdd(variables_1.PAGE_PATTERN, variables_1.CATEGORY_PATTERN, variables_1.API_PATTERN), watcher.onChange(variables_1.PAGE_PATTERN, variables_1.CATEGORY_PATTERN, variables_1.API_PATTERN)).pipe((0, operators_2.bufferUntilOnce)(watcher.onReady()), (0, operators_2.bufferDebounce)(100), (0, operators_1.map)((paths) => (0, core_1.unique)(paths.flat(2))), (0, operators_1.map)((paths) => paths.map((p) => {
        const EntityConstructor = (0, helpers_1.getEntityConstructor)(p);
        const entity = new EntityConstructor(store, cache, context, project.addSourceFileAtPath(p));
        entity.store.set(entity.id, entity);
        return entity;
    })), (0, operators_1.mergeMap)((entities) => (0, rxjs_1.merge)(...entities.map((entity) => (0, rxjs_1.merge)(watcher.onUnlink(...entity.rootFiles), entity.onDestroy()).pipe((0, operators_1.take)(1), (0, operators_1.tap)(() => entity.destroy()), (0, operators_1.map)(() => [entity])))).pipe((0, operators_1.startWith)(entities))), (0, operators_1.mergeMap)((entities) => {
        const notDestroyed = entities.filter((e) => !e.destroyed);
        if (notDestroyed.length) {
            return (0, rxjs_1.forkJoin)(notDestroyed.map(childGenerator)).pipe((0, operators_1.map)((children) => children.flat()), (0, operators_1.switchMap)((children) => (0, rxjs_1.merge)(...children.map((child) => watcher
                .watch(child.rootFiles)
                .onChange(...child.rootFiles)
                .pipe((0, operators_1.map)(() => [child]), (0, rxjs_1.takeUntil)(child.onDestroy())))).pipe((0, operators_1.startWith)((0, core_1.unique)(entities.concat(children))))));
        }
        return (0, rxjs_1.of)(entities);
    }), (0, operators_2.bufferDebounce)(10), (0, operators_1.map)((entities) => entities.flat()), (0, operators_1.map)((entities) => (0, core_1.asArray)(new Set(entities.concat(
    /*
 Add the entities with errors or warnings to the output.
 This is necessary to try to build them again.
*/
    ...store.getAllWithErrorsOrWarnings())))));
}
/**
 * Creates the child entities recursively.
 * @param entity - The entity to create the children for.
 */
function childGenerator(entity) {
    return entity.childrenGenerator().pipe((0, operators_2.progress)('Loading entities...'), (0, operators_1.switchMap)((children) => (0, operators_2.forkJoinOrEmpty)(children.map(childGenerator)).pipe((0, operators_1.map)((children2) => children.concat(children2.flat())))), (0, operators_1.tap)((entities) => entities.forEach((e) => entity.store.set(e.id, e))));
}
//# sourceMappingURL=entity-emitter.js.map