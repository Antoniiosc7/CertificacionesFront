import { __decorate, __metadata } from 'tslib';
import * as i0 from '@angular/core';
import { EventEmitter, ElementRef, NgZone, ChangeDetectorRef, Directive, Output, HostBinding } from '@angular/core';
import { FOCUS_EVENT, BLUR_EVENT } from '@ng-doc/ui-kit/constants';
import { toElement } from '@ng-doc/ui-kit/helpers';
import { ngDocZoneOptimize } from '@ng-doc/ui-kit/observables';
import { untilDestroyed, UntilDestroy } from '@ngneat/until-destroy';
import { merge, fromEvent } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

var NgDocFocusCatcherDirective_1;
let NgDocFocusCatcherDirective = class NgDocFocusCatcherDirective {
    static { NgDocFocusCatcherDirective_1 = this; }
    constructor(elementRef, ngZone, changeDetectorRef) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.focusEvent = new EventEmitter();
        this.blurEvent = new EventEmitter();
        this.focused = false;
        NgDocFocusCatcherDirective_1.observeFocus(toElement(this.elementRef))
            .pipe(ngDocZoneOptimize(this.ngZone), untilDestroyed(this))
            .subscribe((event) => {
            this.focused = event.type === FOCUS_EVENT;
            this.focused ? this.focusEvent.emit(event) : this.blurEvent.emit(event);
            this.changeDetectorRef.markForCheck();
        });
    }
    static observeFocus(element) {
        return merge(fromEvent(element, FOCUS_EVENT), fromEvent(element, BLUR_EVENT)).pipe(debounceTime(0), distinctUntilChanged((a, b) => a.type === b.type));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocFocusCatcherDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.0", type: NgDocFocusCatcherDirective, isStandalone: true, selector: "[ngDocFocusCatcher]", outputs: { focusEvent: "focusEvent", blurEvent: "blurEvent" }, host: { properties: { "attr.data-ng-doc-focused": "this.focused" } }, exportAs: ["ngDocFocusCatcher"], ngImport: i0 }); }
};
NgDocFocusCatcherDirective = NgDocFocusCatcherDirective_1 = __decorate([
    UntilDestroy(),
    __metadata("design:paramtypes", [ElementRef,
        NgZone,
        ChangeDetectorRef])
], NgDocFocusCatcherDirective);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocFocusCatcherDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngDocFocusCatcher]',
                    exportAs: 'ngDocFocusCatcher',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }], propDecorators: { focusEvent: [{
                type: Output
            }], blurEvent: [{
                type: Output
            }], focused: [{
                type: HostBinding,
                args: ['attr.data-ng-doc-focused']
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgDocFocusCatcherDirective };
//# sourceMappingURL=ng-doc-ui-kit-directives-focus-catcher.mjs.map
