import * as i1 from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import * as i0 from '@angular/core';
import { Injector, Injectable, Optional } from '@angular/core';
import * as i2 from '@angular/router';
import { asArray } from '@ng-doc/core/helpers/as-array';
import { NgDocOverlayRef } from '@ng-doc/ui-kit/classes';
import { NgDocOverlayUtils } from '@ng-doc/ui-kit/utils';
import { PolymorpheusComponent } from '@tinkoff/ng-polymorpheus';
import { take } from 'rxjs/operators';

class NgDocOverlayService {
    constructor(overlay, ngZone, injector, router) {
        this.overlay = overlay;
        this.ngZone = ngZone;
        this.injector = injector;
        this.router = router;
    }
    open(content, config, providers = []) {
        const overlayRef = this.createOverlay(config);
        return this.attachTooltipContainer(content, overlayRef, config, providers);
    }
    attachTooltipContainer(content, overlay, config, providers) {
        const containerPortal = new ComponentPortal(config.overlayContainer, config.viewContainerRef, config.viewContainerRef?.injector);
        const containerRef = overlay.attach(containerPortal);
        const overlayRef = new NgDocOverlayRef(overlay, config, containerRef.instance, this.ngZone, this.router);
        if (content instanceof PolymorpheusComponent) {
            content = new PolymorpheusComponent(content.component, this.createInjector(overlayRef, providers, config.viewContainerRef?.injector));
        }
        containerRef.instance.config = config;
        containerRef.instance.content = content;
        containerRef.instance.markForCheck();
        return overlayRef;
    }
    createOverlay(config) {
        const overlayRef = this.overlay.create(config);
        overlayRef
            .detachments()
            .pipe(take(1))
            .subscribe(() => {
            overlayRef.hasAttached() && overlayRef.detach();
        });
        return overlayRef;
    }
    connectedPositionStrategy(origin, positions) {
        return this.overlay
            .position()
            .flexibleConnectedTo(origin)
            .withPositions(NgDocOverlayUtils.toConnectedPositions(asArray(positions)))
            .withPush(true);
    }
    globalPositionStrategy() {
        return this.overlay.position().global();
    }
    scrollStrategy() {
        return this.overlay.scrollStrategies;
    }
    createInjector(overlayRef, providers, injector) {
        return Injector.create({
            providers: [
                ...providers,
                {
                    provide: NgDocOverlayRef,
                    useValue: overlayRef,
                },
            ],
            parent: injector || this.injector,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocOverlayService, deps: [{ token: i1.Overlay }, { token: i0.NgZone }, { token: i0.Injector }, { token: i2.Router, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocOverlayService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocOverlayService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.Overlay }, { type: i0.NgZone }, { type: i0.Injector }, { type: i2.Router, decorators: [{
                    type: Optional
                }] }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgDocOverlayService };
//# sourceMappingURL=ng-doc-ui-kit-services-overlay.mjs.map
