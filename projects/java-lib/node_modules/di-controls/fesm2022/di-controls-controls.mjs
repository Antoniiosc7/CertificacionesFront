import * as i0 from '@angular/core';
import { signal, inject, ElementRef, Renderer2, ChangeDetectorRef, Directive, Input, DestroyRef, computed, effect } from '@angular/core';
import { NgControl } from '@angular/forms';
import { EMPTY_FUNCTION, DI_DEFAULT_COMPARE } from 'di-controls/constants';
import { hasValue } from 'di-controls/helpers';
import { SetCompare } from 'di-controls/classes';

/**
 * Base implementation of ControlValueAccessor
 */
class DIControlValueAccessor {
    incomingUpdate;
    model = signal(null);
    ngControl;
    elementRef = inject(ElementRef);
    changeDetectorRef;
    renderer = inject(Renderer2);
    disabledValue = signal(false);
    touch = EMPTY_FUNCTION;
    change = EMPTY_FUNCTION;
    constructor(incomingUpdate) {
        this.incomingUpdate = incomingUpdate;
        this.ngControl = inject(NgControl, { optional: true, self: true });
        this.changeDetectorRef = inject(ChangeDetectorRef);
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Returns true if the control is not empty.
     */
    get hasValue() {
        return hasValue(this.model());
    }
    /**
     * Returns true if the control is disabled.
     */
    get disabled() {
        return this.disabledValue();
    }
    set disabled(isDisabled) {
        this.setDisabledState(isDisabled);
    }
    /**
     * Method is called by the forms API.
     *
     * @param fn - callback function to register on value change
     * @internal
     */
    registerOnChange(fn) {
        this.change = fn;
    }
    /**
     * Method is called by the forms API.
     *
     * @param fn - callback function to register on touch
     * @internal
     */
    registerOnTouched(fn) {
        this.touch = fn;
    }
    /**
     * Method is called by the forms API to write to the view when programmatic changes from model to view are requested.
     *
     * @param obj - new value
     * @internal
     */
    writeValue(obj) {
        if (this.model() !== obj) {
            this.update(obj);
        }
    }
    /**
     * Updates the model. Use this method to update model from your Control
     *
     * @param value - new value
     */
    updateModel(value) {
        this.model.set(value);
        this.change(this.model());
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Method is called by the forms API to write to the view when programmatic changes from model to view are requested.
     *
     * @param isDisabled - new value
     * @internal
     */
    setDisabledState(isDisabled) {
        this.disabledValue.set(isDisabled);
        this.disabledValue()
            ? this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true')
            : this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
        this.renderer.setAttribute(this.elementRef.nativeElement, 'aria-disabled', `${this.disabledValue()}`);
    }
    update(value) {
        this.model.set(value);
        this.incomingUpdate && this.incomingUpdate(value);
        this.changeDetectorRef.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControlValueAccessor, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIControlValueAccessor, inputs: { disabled: "disabled" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControlValueAccessor, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; }, propDecorators: { disabled: [{
                type: Input
            }] } });

/**
 * `DIControl` can be used to implement any control that you want. It can work with any model type.
 * All updates from children will be accepted as is. And updates from outside (`FormControl`, `NgModel`, another Control)
 * will be accepted as is too.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DIControl` class.
 * After that your control will be able to work with `NgModel`, `FormControl`.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *    super();
 *  }
 * }
 *  ```
 *
 * ## Registering as a host
 * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host
 * for another controls, then your control will be able to update them and accept updates from them. To do that you need to
 * use `provideHostControl` function.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideHostControl(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *   }
 * }
 * ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({host: injectHostControl({optional: true})});
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.model());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you need to call `updateModel` method. It will update model for the current control and all
 * children controls, as well as for the `NgModel` or `FormControl`.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.updateModel('new value');
 *   }
 * }
 * ```
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: string | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 */
class DIControl extends DIControlValueAccessor {
    config;
    /**
     * List of children controls.
     *
     * @protected
     * @internal
     */
    children = new Set();
    /**
     * Control from which we have to update our model.
     *
     * @protected
     * @internal
     */
    updateFrom = null;
    /**
     * Request host for update the current control.
     * Host will update the current control based on its current state and host control logic.
     *
     * @protected
     * @internal
     */
    requestForUpdate = EMPTY_FUNCTION;
    /**
     * Function that should be used to make control touched.
     */
    touch = () => this.config?.host?.touch();
    onControlChangeFn = EMPTY_FUNCTION;
    destroyRef = inject(DestroyRef);
    constructor(config) {
        super(config?.onIncomingUpdate);
        this.config = config;
        this.destroyRef.onDestroy(() => this.config?.host?.unregisterControl(this));
    }
    ngOnInit() {
        /*
         * We have to register control with Promise.resolve because NgModel uses it too to set first
         * value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)
         */
        Promise.resolve().then(() => this.config?.host?.registerControl(this));
    }
    /**
     * Registers provided control as a child of the current control.
     *
     * @param control - control that will be registered.
     * @internal
     */
    registerControl(control) {
        this.children.add(control);
        /*
         * We have to update control because its can be created dynamically.
         * We use Promise.resolve because NgModel uses it too to set first value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)
         * so there's no need to use angular life cycle hooks
         */
        Promise.resolve().then(() => {
            this.updateControl(control, this.model());
        });
        control.registerOnControlChange((value) => {
            this.childControlChange(control, value);
            this.config?.onChildControlChange?.(control, value);
        });
        control.registerRequestForUpdate(() => {
            this.updateControl(control, this.model());
        });
    }
    /**
     * Unregisters provided control from the current control.
     *
     * @param control - control that will be unregistered.
     * @internal
     */
    unregisterControl(control) {
        this.children.delete(control);
    }
    registerOnTouched(fn) {
        this.touch = () => {
            fn();
            // Touch host control to update its state
            this.config?.host?.touch();
        };
    }
    /**
     * Registers provided function as a callback that will be called when the current control changes.
     * This function will be provided by the host control to update its model.
     *
     * @param fn - callback function.
     * @internal
     */
    registerOnControlChange(fn) {
        this.onControlChangeFn = fn;
    }
    /**
     * Registers provided function as a callback that can be called to request an update from the host control.
     * After calling this function the host control will update the model of the current control based on the current
     * state of the control and host control logic.
     *
     * @param fn - callback function.
     * @internal
     */
    registerRequestForUpdate(fn) {
        this.requestForUpdate = fn;
    }
    /**
     * Updates the model of the current control.
     * This is the main method that should be used to update the model.
     *
     * @param value - new value.
     */
    updateModel(value) {
        super.updateModel(value);
        this.onControlChangeFn(value);
        this.updateControls(this.model());
    }
    writeValue(value) {
        if (this.model() !== value) {
            super.writeValue(value);
            this.updateControls(value);
            this.onControlChangeFn(value);
        }
    }
    /**
     * Method is called by the host to update the value of the control.
     *
     * @param value - new value
     * @internal
     */
    writeValueFromHost(value) {
        if (this.model() !== value) {
            super.writeValue(value);
            this.change(value);
            this.updateControls(value);
        }
    }
    /**
     * Updates all child controls with the provided value.
     *
     * @param value - new value.
     * @protected
     * @internal
     */
    updateControls(value) {
        this.children.forEach((control) => {
            if (control !== this.updateFrom) {
                this.updateControl(control, value);
            }
        });
        this.updateFrom = null;
    }
    /**
     * Updates provided control with the provided value.
     *
     * @param control - control that will be updated.
     * @param value - new value.
     * @protected
     * @internal
     */
    updateControl(control, value) {
        control.writeValueFromHost(value);
    }
    /**
     * Function catches updates from child controls and updates the current control model.
     *
     * @param control - control that was updated.
     * @param value - new value.
     * @protected
     * @internal
     */
    childControlChange(control, value) {
        if (this.model() !== value) {
            this.updateFrom = control;
            this.updateModel(value);
            this.incomingUpdate && this.incomingUpdate(value);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIControl, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControl, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; } });

/**
 * `DIStateControl` can be used to implement state controls (checkbox, radio, chip, switch, etc.).
 * It extends `DIControl` and adds `checked` signal that can be used to get checked state.
 * By default it works with `boolean` type, it adds `value` input that can be used to set custom
 * "true" value.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DIStateControl` class.
 * After that your control will be able to work with `NgModel`, `FormControl`.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *    super();
 *  }
 * }
 *  ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({host: injectHostControl({optional: true})});
 *   }
 * }
 * ```
 *
 * ## Getting checked state
 * To get checked state you need to use `checked` signal. It will return `true` if the current control is checked,
 * `false` if it is unchecked and `null` if it is in intermediate state.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *
 *     console.log(this.checked());
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.checked());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you should use `check`, `uncheck`, `intermediate` or `toggle` methods.
 * They will update model based on the current state and configuration.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.toggle();
 *   }
 * }
 * ```
 *
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T>  {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: string | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 *
 * ## Changing styles based on the state
 * `DIStateControl` binds `aria-checked` attribute to the host element.
 * You can use it to change styles of your child elements.
 *
 * ```ts {7,12,17} fileName="custom-control.component.ts"
 * @Component({
 *   selector: 'custom-control',
 *   template: ``,
 *   styles: [`
 *     :host {
 *       // checked
 *       &[aria-checked="true"] {
 *         color: green;
 *       }
 *
 *       // unchecked
 *       &[aria-checked="false"] {
 *         color: red;
 *       }
 *
 *       // intermediate
 *       &[aria-checked="mixed"] {
 *         color: blue;
 *       }
 *   `],
 *   changeDetection: ChangeDetectionStrategy.OnPush,
 *  })
 *  export class CustomControlComponent<T = boolean> extends DIStateControl<T>  {
 *    constructor() {
 *      super();
 *    }
 *  }
 *  ```
 *
 *  ## Using with DICollectionControl
 *  Using `DIStateControl` together with `DICollectionControl` will result in
 *  `DICollectionControl` containing a list of values from `DIStateControl` that have
 *  a checked state. If your `DIStateControl` has objects as values, you may
 *  likely need a comparison function because they can sometimes be immutable.
 *
 * To achieve this, provide your `DICollectionControl` as a `DICompareHost` and
 * inject it into your `DIStateControl` to give `DIStateControl` access to
 * the `compareFn` function.
 *
 * ```ts {3-4} fileName="checkbox-group.component.ts"
 * @Component({
 *   providers: [
 *     provideHostControl(CheckboxGroupComponent),
 *     provideCompareHost(CheckboxGroupComponent),
 *   ],
 * })
 * export class CheckboxGroupComponent<T> extends DICollectionControl<T> {
 *   constructor() {
 *     super();
 *   }
 * }
 * ```
 *
 * ```ts {5-7} fileName="checkbox.component.ts"
 * @Component()
 * export class CheckboxComponent<T> extends DIStateControl<T> {
 *   constructor() {
 *     super({
 *       host: injectHostControl({ optional: true }),
 *       compareHost: inject(DICompareHost, { optional: true }),
 *       hasIntermediate: true,
 *     });
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.toggle();
 *   }
 * }
 * ```
 */
class DIStateControl extends DIControl {
    config;
    value = true;
    checked = computed(() => {
        const compareFn = this.config?.compareHost?.compareFn ?? DI_DEFAULT_COMPARE;
        return compareFn(this.value, this.model()) ? true : this.isIntermediate ? null : false;
    });
    constructor(config) {
        super(config);
        this.config = config;
        // Setting aria attributes
        effect(() => {
            const ariaChecked = this.checked() === null ? 'mixed' : this.checked();
            this.renderer.setAttribute(this.elementRef.nativeElement, 'aria-checked', `${ariaChecked}`);
        });
    }
    ngOnChanges({ value }) {
        /*
         * We have to request host for updates, because when we use ngFor directive
         * with trackBy function, Angular doesn't re-create components, it just changes their inputs,
         * so we have to request for updates our host, to determine right checked state
         */
        if (value) {
            this.requestForUpdate();
        }
    }
    /** Sets checked state */
    check() {
        this.updateModel(this.value);
    }
    /** Sets unchecked state */
    uncheck() {
        this.updateModel(false);
    }
    /** Sets intermediate state */
    intermediate() {
        this.updateModel(null);
    }
    /** Toggles checked state */
    toggle() {
        this.updateModel(this.checked() === false ? this.value : false);
    }
    get isIntermediate() {
        return this.model() === null && !!this.config?.hasIntermediate;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIStateControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIStateControl, inputs: { value: "value" }, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIStateControl, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: function () { return [{ type: undefined }]; }, propDecorators: { value: [{
                type: Input
            }] } });

/**
 * `DICollectionControl` can be used to implement array controls (checkbox group, radio group, chips, etc.).
 * It has an additional integration with `DIStateControl` that allows you to use it as a host for
 * `DIStateControl` controls. If you use `DIStateControl` as a child control, then `DICollectionControl`
 * will update its model when the child control is checked or unchecked, so `DICollectionControl` will
 * contain only checked values.
 *
 * It also works with other controls, but their model should be an array.
 *
 * > **Warning**
 * > If child control model is updated with non-array value, then `DICollectionControl` will be updated with `null`.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DICollectionControl` class.
 * After that your control will be able to work with `NgModel`, `FormControl`.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *    super();
 *  }
 * }
 *  ```
 *
 * ## Registering as a host
 * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host
 * for another controls, then your control will be able to update them and accept updates from them. To do that you need to
 * use `provideHostControl` function.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideHostControl(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super();
 *   }
 * }
 * ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({host: injectHostControl({optional: true})});
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.model());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you need to call `updateModel` method. It will update model for the current control and all
 * children controls, as well as for the `NgModel` or `FormControl`.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.updateModel(['new value']);
 *   }
 * }
 * ```
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: string[] | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 *
 * ## Comparing values
 * By default `DICollectionControl` uses `===` operator to compare values. It may be not enough for some cases,
 * for example, when you want to compare immutable objects. To solve this problem you can provide `compareFn`
 * function and provide your control as a `DICompareHost`. It will be used to compare values in the array.
 *
 * > **Warning**
 * > This function will be used by `DIStateControl` to compare values, to set checked state.
 * > Don't forget to inject `DICompareHost` in your `DIStateControl` to make it work.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideCompareHost(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DICollectionControl<string> {
 *  constructor() {
 *    super()
 *  }
 * }
 * ```
 */
class DICollectionControl extends DIControl {
    config;
    /**
     * Function that will be used to compare values in the array.
     * Useful when you want to compare objects by some property (e.g. `id`).
     */
    compareFn = DI_DEFAULT_COMPARE;
    proxyModel = new SetCompare();
    constructor(config) {
        super(config);
        this.config = config;
    }
    updateModel(obj) {
        this.proxyModel = new SetCompare(this.compareFn, obj);
        super.updateModel(obj);
    }
    writeValue(value) {
        this.proxyModel = new SetCompare(this.compareFn, value);
        super.writeValue(value);
    }
    writeValueFromHost(obj) {
        this.proxyModel = new SetCompare(this.compareFn, obj);
        super.writeValueFromHost(obj);
    }
    childControlChange(control, value) {
        this.updateFrom = control;
        this.updateModel(this.getNewModel(control, value));
        this.incomingUpdate && this.incomingUpdate(this.model());
    }
    getNewModel(control, updates) {
        if (control instanceof DIStateControl) {
            control.checked()
                ? this.proxyModel.add(control.value)
                : this.proxyModel.delete(control.value);
        }
        else if (Array.isArray(updates)) {
            this.proxyModel = new SetCompare(this.compareFn, updates);
        }
        else {
            this.proxyModel = new SetCompare(this.compareFn);
            return null;
        }
        return this.proxyModel.toArray();
    }
    updateControl(control) {
        if (control instanceof DIStateControl) {
            control.writeValueFromHost(this.proxyModel.has(control.value) ? control.value : false);
        }
        else {
            control.writeValueFromHost(this.model());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DICollectionControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DICollectionControl, inputs: { compareFn: "compareFn" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DICollectionControl, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; }, propDecorators: { compareFn: [{
                type: Input
            }] } });

/**
 * `DIProxyControl` is very suitable.
 * It is typically used as a host and works exclusively with objects. It is
 * necessary to bind child controls to a specific property of the object,
 * thereby ensuring that they update only that specific property and not the
 * entire object as a whole. Please see `*DateRangePage`.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DIProxyControl` class
 * and provide `getValue` and `setValue` functions that will be used to get and set value from the object
 * to the child control.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIProxyControl<MyObject> {
 *   constructor() {
 *    super({
 *      getValue: (model) => model.objectProperty,
 *      setValue: (model, value) => ({...model, objectProperty: value}),
 *    });
 *  }
 * }
 *  ```
 *
 * ## Registering as a host
 * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host
 * for another controls, then your control will be able to update them and accept updates from them. To do that you need to
 * use `provideHostControl` function.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideHostControl(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DIProxyControl<MyObject> {
 *   constructor() {
 *     super({
 *      getValue: (model) => model.objectProperty,
 *      setValue: (model, value) => ({...model, objectProperty: value}),
 *    });
 *   }
 * }
 * ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIProxyControl<MyObject> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({
 *       host: injectHostControl({optional: true}),
 *       getValue: (model) => model.objectProperty,
 *       setValue: (model, value) => ({...model, objectProperty: value}),
 *     });
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIProxyControl<MyObject> {
 *   constructor() {
 *     super(
 *       getValue: (model) => model.objectProperty,
 *       setValue: (model, value) => ({...model, objectProperty: value}),
 *     );
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.model());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you need to call `updateModel` method. It will update model for the current control and all
 * children controls, as well as for the `NgModel` or `FormControl`.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIProxyControl<MyObject> {
 *   constructor() {
 *     super(
 *       getValue: (model) => model.objectProperty,
 *       setValue: (model, value) => ({...model, objectProperty: value}),
 *     );
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.updateModel({objectProperty: 'new value'});
 *   }
 * }
 * ```
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIProxyControl<MyObject> {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: MyObject | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 */
class DIProxyControl extends DIControl {
    config;
    constructor(config) {
        super(config);
        this.config = config;
    }
    registerControl(control) {
        this.children.add(control);
        /*
         * We have to update control because its can be created dynamically.
         * We use Promise.resolve because NgModel uses it too to set first value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)
         * so there's no need to use angular life cycle hooks
         */
        Promise.resolve().then(() => control.writeValueFromHost(this.config.getValue(this.model())));
        control.registerOnControlChange((value) => {
            this.updateFrom = control;
            this.updateModel(this.config.setValue(this.model(), value));
        });
        control.registerRequestForUpdate(() => {
            control.writeValueFromHost(this.config.getValue(this.model()));
        });
    }
    updateControl(control, value) {
        control.writeValueFromHost(this.config.getValue(value));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIProxyControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIProxyControl, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIProxyControl, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { DICollectionControl, DIControl, DIControlValueAccessor, DIProxyControl, DIStateControl };
//# sourceMappingURL=di-controls-controls.mjs.map
