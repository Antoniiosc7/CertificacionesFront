{"version":3,"file":"di-controls-controls.mjs","sources":["../../../../libs/di-controls/controls/control-value-accessor.ts","../../../../libs/di-controls/controls/control.ts","../../../../libs/di-controls/controls/state-control.ts","../../../../libs/di-controls/controls/collection-control.ts","../../../../libs/di-controls/controls/proxy-control.ts","../../../../libs/di-controls/controls/di-controls-controls.ts"],"sourcesContent":["import {\n\tChangeDetectorRef,\n\tDirective,\n\tElementRef,\n\tinject,\n\tInput,\n\tRenderer2, Signal,\n\tsignal,\n\tWritableSignal\n} from '@angular/core';\nimport {ControlValueAccessor, NgControl} from '@angular/forms';\nimport {EMPTY_FUNCTION} from 'di-controls/constants';\nimport {hasValue} from 'di-controls/helpers';\n\n/**\n * Base implementation of ControlValueAccessor\n */\n@Directive()\nexport abstract class DIControlValueAccessor<T> implements ControlValueAccessor {\n\tprotected readonly model: Signal<T | null> = signal(null);\n\tprotected readonly ngControl: NgControl | null;\n\tprotected readonly elementRef: ElementRef<HTMLElement> = inject(ElementRef);\n\tprotected readonly changeDetectorRef: ChangeDetectorRef;\n\tprotected readonly renderer: Renderer2 = inject(Renderer2);\n\tprotected readonly disabledValue: WritableSignal<boolean> = signal(false);\n\n\tprotected touch: () => void = EMPTY_FUNCTION;\n\tprotected change: (value: T | null) => void = EMPTY_FUNCTION;\n\n\tprotected constructor(protected readonly incomingUpdate?: (value: T | null) => void) {\n\t\tthis.ngControl = inject(NgControl, { optional: true, self: true });\n\t\tthis.changeDetectorRef = inject(ChangeDetectorRef);\n\n\t\tif (this.ngControl) {\n\t\t\tthis.ngControl.valueAccessor = this;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the control is not empty.\n\t */\n\tget hasValue(): boolean {\n\t\treturn hasValue(this.model());\n\t}\n\n\t/**\n\t * Returns true if the control is disabled.\n\t */\n\t@Input()\n\tget disabled(): boolean {\n\t\treturn this.disabledValue();\n\t}\n\n\tset disabled(isDisabled: boolean) {\n\t\tthis.setDisabledState(isDisabled);\n\t}\n\n\t/**\n\t * Method is called by the forms API.\n\t *\n\t * @param fn - callback function to register on value change\n\t * @internal\n\t */\n\tregisterOnChange(fn: (value: T | null) => void): void {\n\t\tthis.change = fn;\n\t}\n\n\t/**\n\t * Method is called by the forms API.\n\t *\n\t * @param fn - callback function to register on touch\n\t * @internal\n\t */\n\tregisterOnTouched(fn: () => void): void {\n\t\tthis.touch = fn;\n\t}\n\n\t/**\n\t * Method is called by the forms API to write to the view when programmatic changes from model to view are requested.\n\t *\n\t * @param obj - new value\n\t * @internal\n\t */\n\twriteValue(obj: T | null): void {\n\t\tif (this.model() !== obj) {\n\t\t\tthis.update(obj);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the model. Use this method to update model from your Control\n\t *\n\t * @param value - new value\n\t */\n\tupdateModel(value: T | null): void {\n\t\t(this.model as WritableSignal<T | null>).set(value);\n\t\tthis.change(this.model());\n\t\tthis.changeDetectorRef.markForCheck();\n\t}\n\n\t/**\n\t * Method is called by the forms API to write to the view when programmatic changes from model to view are requested.\n\t *\n\t * @param isDisabled - new value\n\t * @internal\n\t */\n\tsetDisabledState(isDisabled: boolean): void {\n\t\tthis.disabledValue.set(isDisabled);\n\n\t\tthis.disabledValue()\n\t\t\t? this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true')\n\t\t\t: this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');\n\t\tthis.renderer.setAttribute(\n\t\t\tthis.elementRef.nativeElement,\n\t\t\t'aria-disabled',\n\t\t\t`${this.disabledValue()}`,\n\t\t);\n\t}\n\n\tprivate update(value: T | null): void {\n\t\t(this.model as WritableSignal<T | null>).set(value);\n\t\tthis.incomingUpdate && this.incomingUpdate(value);\n\t\tthis.changeDetectorRef.markForCheck();\n\t}\n}\n","import { DestroyRef, Directive, inject, OnInit } from '@angular/core';\nimport { DIControlValueAccessor } from './control-value-accessor';\nimport { EMPTY_FUNCTION } from 'di-controls/constants';\n\n/**\n * Configuration for the `DIControl`.\n */\nexport interface DIControlConfig<TModel, TChildModel> {\n  /**\n   * Host control for the current control. It can be injected using `DI_HOST_CONTROL` token.\n   */\n  host?: DIControl<any, TModel> | null;\n  /**\n   * Function that will be called when the current control receives an update from the host control or from the\n   * Forms API.\n   *\n   * @param value - new value.\n   */\n  onIncomingUpdate?: (value: TModel | null) => void;\n  /**\n   * Function that will be called when the current control receives an update from the child control.\n   *\n   * @param control - child control that was updated.\n   * @param value - new value.\n   */\n  onChildControlChange?: (control: DIControl<TChildModel>, value: TModel | null) => void;\n}\n\n/**\n * `DIControl` can be used to implement any control that you want. It can work with any model type.\n * All updates from children will be accepted as is. And updates from outside (`FormControl`, `NgModel`, another Control)\n * will be accepted as is too.\n *\n * ## Creating a control\n * To create a control you need to extend your `@Component` or `@Directive` from `DIControl` class.\n * After that your control will be able to work with `NgModel`, `FormControl`.\n *\n * ```ts fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *    super();\n *  }\n * }\n *  ```\n *\n * ## Registering as a host\n * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host\n * for another controls, then your control will be able to update them and accept updates from them. To do that you need to\n * use `provideHostControl` function.\n *\n * ```ts {2} fileName=\"custom-control.component.ts\"\n * @Component({\n *   providers: [provideHostControl(CustomControlComponent)],\n * })\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *     super();\n *   }\n * }\n * ```\n *\n * ## Injecting host control\n * By default your control doesn't communicate with host controls. But you can inject host control and put it\n * into `super` call. This will register your control in the host control and start communication between them.\n *\n * > **Note**\n * > If you register your control as a host for another controls, then you can inject it\n * > only with `skipSelf` option.\n *\n * ```ts {5} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *     // we add `optional` option to make it possible to use this control without host\n *     super({host: injectHostControl({optional: true})});\n *   }\n * }\n * ```\n *\n * ## Getting model\n * To get model you need to use `model` property. It will return model for the current control.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *     super();\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     console.log(this.model());\n *   }\n * }\n * ```\n *\n * ## Updating model\n * To update model you need to call `updateModel` method. It will update model for the current control and all\n * children controls, as well as for the `NgModel` or `FormControl`.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *     super();\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     this.updateModel('new value');\n *   }\n * }\n * ```\n * ## Catching updates\n * Sometimes you may need to catch updates from different sources. For example, to update the value of the native\n * input element. To do this, you can provide the `onIncomingUpdate` hook.\n *\n * ```ts {6} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *     super({\n *       onIncomingUpdate: (value: string | null) => {\n *         this.elementRef.nativeElement.value = value;\n *       },\n *     });\n *   }\n * }\n * ```\n */\n@Directive()\nexport abstract class DIControl<TModel, TChildModel = TModel>\n  extends DIControlValueAccessor<TModel>\n  implements OnInit\n{\n  /**\n   * List of children controls.\n   *\n   * @protected\n   * @internal\n   */\n  protected children: Set<DIControl<TChildModel>> = new Set<DIControl<TChildModel>>();\n  /**\n   * Control from which we have to update our model.\n   *\n   * @protected\n   * @internal\n   */\n  protected updateFrom: DIControl<TChildModel> | null = null;\n\n  /**\n   * Request host for update the current control.\n   * Host will update the current control based on its current state and host control logic.\n   *\n   * @protected\n   * @internal\n   */\n  protected requestForUpdate: () => void = EMPTY_FUNCTION;\n  /**\n   * Function that should be used to make control touched.\n   */\n  protected override touch: () => void = () => this.config?.host?.touch();\n\n  private onControlChangeFn: (value: TModel | null) => void = EMPTY_FUNCTION;\n  private destroyRef: DestroyRef = inject(DestroyRef);\n\n  protected constructor(protected readonly config?: DIControlConfig<TModel, TChildModel>) {\n    super(config?.onIncomingUpdate);\n\n    this.destroyRef.onDestroy(() => this.config?.host?.unregisterControl(this));\n  }\n\n  ngOnInit(): void {\n    /*\n     * We have to register control with Promise.resolve because NgModel uses it too to set first\n     * value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)\n     */\n    Promise.resolve().then(() => this.config?.host?.registerControl(this));\n  }\n\n  /**\n   * Registers provided control as a child of the current control.\n   *\n   * @param control - control that will be registered.\n   * @internal\n   */\n  registerControl(control: DIControl<TChildModel>): void {\n    this.children.add(control);\n\n    /*\n     * We have to update control because its can be created dynamically.\n     * We use Promise.resolve because NgModel uses it too to set first value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)\n     * so there's no need to use angular life cycle hooks\n     */\n    Promise.resolve().then(() => {\n      this.updateControl(control, this.model());\n    });\n\n    control.registerOnControlChange((value: unknown | null) => {\n      this.childControlChange(control, value as TModel | null);\n      this.config?.onChildControlChange?.(control, value as TModel | null);\n    });\n\n    control.registerRequestForUpdate(() => {\n      this.updateControl(control, this.model());\n    });\n  }\n\n  /**\n   * Unregisters provided control from the current control.\n   *\n   * @param control - control that will be unregistered.\n   * @internal\n   */\n  unregisterControl(control: DIControl<TChildModel>): void {\n    this.children.delete(control);\n  }\n\n  override registerOnTouched(fn: () => void): void {\n    this.touch = () => {\n      fn();\n\n      // Touch host control to update its state\n      this.config?.host?.touch();\n    };\n  }\n\n  /**\n   * Registers provided function as a callback that will be called when the current control changes.\n   * This function will be provided by the host control to update its model.\n   *\n   * @param fn - callback function.\n   * @internal\n   */\n  registerOnControlChange(fn: (value: TModel | null) => void): void {\n    this.onControlChangeFn = fn;\n  }\n\n  /**\n   * Registers provided function as a callback that can be called to request an update from the host control.\n   * After calling this function the host control will update the model of the current control based on the current\n   * state of the control and host control logic.\n   *\n   * @param fn - callback function.\n   * @internal\n   */\n  registerRequestForUpdate(fn: () => void): void {\n    this.requestForUpdate = fn;\n  }\n\n  /**\n   * Updates the model of the current control.\n   * This is the main method that should be used to update the model.\n   *\n   * @param value - new value.\n   */\n  override updateModel(value: TModel | null): void {\n    super.updateModel(value);\n    this.onControlChangeFn(value);\n    this.updateControls(this.model());\n  }\n\n  override writeValue(value: TModel | null): void {\n    if (this.model() !== value) {\n      super.writeValue(value);\n      this.updateControls(value);\n      this.onControlChangeFn(value);\n    }\n  }\n\n  /**\n   * Method is called by the host to update the value of the control.\n   *\n   * @param value - new value\n   * @internal\n   */\n  writeValueFromHost(value: TModel | null): void {\n    if (this.model() !== value) {\n      super.writeValue(value);\n      this.change(value);\n      this.updateControls(value);\n    }\n  }\n\n  /**\n   * Updates all child controls with the provided value.\n   *\n   * @param value - new value.\n   * @protected\n   * @internal\n   */\n  protected updateControls(value: TModel | null): void {\n    this.children.forEach((control: DIControl<TChildModel>) => {\n      if (control !== this.updateFrom) {\n        this.updateControl(control, value);\n      }\n    });\n    this.updateFrom = null;\n  }\n\n  /**\n   * Updates provided control with the provided value.\n   *\n   * @param control - control that will be updated.\n   * @param value - new value.\n   * @protected\n   * @internal\n   */\n  protected updateControl(control: DIControl<TChildModel>, value: TModel | null): void {\n    control.writeValueFromHost(value as TChildModel);\n  }\n\n  /**\n   * Function catches updates from child controls and updates the current control model.\n   *\n   * @param control - control that was updated.\n   * @param value - new value.\n   * @protected\n   * @internal\n   */\n  protected childControlChange(control: DIControl<TChildModel>, value: TModel | null): void {\n    if (this.model() !== value) {\n      this.updateFrom = control;\n      this.updateModel(value);\n      this.incomingUpdate && this.incomingUpdate(value);\n    }\n  }\n}\n","import {computed, Directive, effect, Input, OnChanges, Signal, SimpleChanges} from '@angular/core';\nimport {DICompareHost} from 'di-controls/classes';\nimport {DI_DEFAULT_COMPARE} from 'di-controls/constants';\nimport {DIControl, DIControlConfig} from './control';\nimport {DICompareFunction} from 'di-controls/types';\n\n/**\n * Configuration for the `DIStateControl`.\n */\nexport interface DIStateControlConfig<TModel> extends DIControlConfig<TModel, TModel> {\n\t/**\n\t * Function that will be used to compare host value with the current control value.\n\t */\n\tcompareHost?: DICompareHost<TModel | null> | null;\n\t/**\n\t * Indicates whether the current control can have intermediate state.\n\t */\n\thasIntermediate?: boolean;\n}\n\n/**\n * `DIStateControl` can be used to implement state controls (checkbox, radio, chip, switch, etc.).\n * It extends `DIControl` and adds `checked` signal that can be used to get checked state.\n * By default it works with `boolean` type, it adds `value` input that can be used to set custom\n * \"true\" value.\n *\n * ## Creating a control\n * To create a control you need to extend your `@Component` or `@Directive` from `DIStateControl` class.\n * After that your control will be able to work with `NgModel`, `FormControl`.\n *\n * ```ts fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {\n *   constructor() {\n *    super();\n *  }\n * }\n *  ```\n *\n * ## Injecting host control\n * By default your control doesn't communicate with host controls. But you can inject host control and put it\n * into `super` call. This will register your control in the host control and start communication between them.\n *\n * > **Note**\n * > If you register your control as a host for another controls, then you can inject it\n * > only with `skipSelf` option.\n *\n * ```ts {5} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {\n *   constructor() {\n *     // we add `optional` option to make it possible to use this control without host\n *     super({host: injectHostControl({optional: true})});\n *   }\n * }\n * ```\n *\n * ## Getting checked state\n * To get checked state you need to use `checked` signal. It will return `true` if the current control is checked,\n * `false` if it is unchecked and `null` if it is in intermediate state.\n *\n * ```ts {6} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIControl<string> {\n *   constructor() {\n *     super();\n *\n *     console.log(this.checked());\n *   }\n * }\n * ```\n *\n * ## Getting model\n * To get model you need to use `model` property. It will return model for the current control.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {\n *   constructor() {\n *     super();\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     console.log(this.checked());\n *   }\n * }\n * ```\n *\n * ## Updating model\n * To update model you should use `check`, `uncheck`, `intermediate` or `toggle` methods.\n * They will update model based on the current state and configuration.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {\n *   constructor() {\n *     super();\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     this.toggle();\n *   }\n * }\n * ```\n *\n * ## Catching updates\n * Sometimes you may need to catch updates from different sources. For example, to update the value of the native\n * input element. To do this, you can provide the `onIncomingUpdate` hook.\n *\n * ```ts {6} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent<T = boolean> extends DIStateControl<T>  {\n *   constructor() {\n *     super({\n *       onIncomingUpdate: (value: string | null) => {\n *         this.elementRef.nativeElement.value = value;\n *       },\n *     });\n *   }\n * }\n * ```\n *\n * ## Changing styles based on the state\n * `DIStateControl` binds `aria-checked` attribute to the host element.\n * You can use it to change styles of your child elements.\n *\n * ```ts {7,12,17} fileName=\"custom-control.component.ts\"\n * @Component({\n *   selector: 'custom-control',\n *   template: ``,\n *   styles: [`\n *     :host {\n *       // checked\n *       &[aria-checked=\"true\"] {\n *         color: green;\n *       }\n *\n *       // unchecked\n *       &[aria-checked=\"false\"] {\n *         color: red;\n *       }\n *\n *       // intermediate\n *       &[aria-checked=\"mixed\"] {\n *         color: blue;\n *       }\n *   `],\n *   changeDetection: ChangeDetectionStrategy.OnPush,\n *  })\n *  export class CustomControlComponent<T = boolean> extends DIStateControl<T>  {\n *    constructor() {\n *      super();\n *    }\n *  }\n *  ```\n *\n *  ## Using with DICollectionControl\n *  Using `DIStateControl` together with `DICollectionControl` will result in\n *  `DICollectionControl` containing a list of values from `DIStateControl` that have\n *  a checked state. If your `DIStateControl` has objects as values, you may\n *  likely need a comparison function because they can sometimes be immutable.\n *\n * To achieve this, provide your `DICollectionControl` as a `DICompareHost` and\n * inject it into your `DIStateControl` to give `DIStateControl` access to\n * the `compareFn` function.\n *\n * ```ts {3-4} fileName=\"checkbox-group.component.ts\"\n * @Component({\n *   providers: [\n *     provideHostControl(CheckboxGroupComponent),\n *     provideCompareHost(CheckboxGroupComponent),\n *   ],\n * })\n * export class CheckboxGroupComponent<T> extends DICollectionControl<T> {\n *   constructor() {\n *     super();\n *   }\n * }\n * ```\n *\n * ```ts {5-7} fileName=\"checkbox.component.ts\"\n * @Component()\n * export class CheckboxComponent<T> extends DIStateControl<T> {\n *   constructor() {\n *     super({\n *       host: injectHostControl({ optional: true }),\n *       compareHost: inject(DICompareHost, { optional: true }),\n *       hasIntermediate: true,\n *     });\n *\n *   @HostListener('click')\n *   onClick() {\n *     this.toggle();\n *   }\n * }\n * ```\n */\n@Directive({})\nexport abstract class DIStateControl<TModel>\n\textends DIControl<TModel | boolean>\n\timplements OnChanges\n{\n\t@Input()\n\tvalue: TModel | true = true;\n\n\tchecked: Signal<boolean | null> = computed(() => {\n\t\tconst compareFn: DICompareFunction<TModel | boolean> =\n\t\t\tthis.config?.compareHost?.compareFn ?? DI_DEFAULT_COMPARE;\n\n\t\treturn compareFn(this.value, this.model()) ? true : this.isIntermediate ? null : false;\n\t});\n\n\tprotected constructor(\n\t\tprotected override readonly config?: DIStateControlConfig<TModel | boolean>,\n\t) {\n\t\tsuper(config);\n\n\t\t// Setting aria attributes\n\t\teffect(() => {\n\t\t\tconst ariaChecked = this.checked() === null ? 'mixed' : this.checked();\n\n\t\t\tthis.renderer.setAttribute(this.elementRef.nativeElement, 'aria-checked', `${ariaChecked}`);\n\t\t});\n\t}\n\n\tngOnChanges({ value }: SimpleChanges): void {\n\t\t/*\n\t\t * We have to request host for updates, because when we use ngFor directive\n\t\t * with trackBy function, Angular doesn't re-create components, it just changes their inputs,\n\t\t * so we have to request for updates our host, to determine right checked state\n\t\t */\n\t\tif (value) {\n\t\t\tthis.requestForUpdate();\n\t\t}\n\t}\n\n\t/** Sets checked state */\n\tcheck(): void {\n\t\tthis.updateModel(this.value);\n\t}\n\n\t/** Sets unchecked state */\n\tuncheck(): void {\n\t\tthis.updateModel(false);\n\t}\n\n\t/** Sets intermediate state */\n\tintermediate(): void {\n\t\tthis.updateModel(null);\n\t}\n\n\t/** Toggles checked state */\n\ttoggle(): void {\n\t\tthis.updateModel(this.checked() === false ? this.value : false);\n\t}\n\n\tget isIntermediate(): boolean {\n\t\treturn this.model() === null && !!this.config?.hasIntermediate;\n\t}\n}\n","import {Directive, Input} from '@angular/core';\nimport {DICompareHost, SetCompare} from 'di-controls/classes';\nimport {DI_DEFAULT_COMPARE} from 'di-controls/constants';\nimport {DICompareFunction} from 'di-controls/types';\nimport {DIControl, DIControlConfig} from './control';\nimport {DIStateControl} from './state-control';\n\n/**\n * Configuration for the `DICollectionControl`.\n */\nexport interface DICollectionControlConfig<TModel, TChildModel> extends DIControlConfig<TModel[], TChildModel> {\n\t/**\n\t * Function that will be used to compare values in the array.\n\t * Useful when you want to compare objects by some property.\n\t */\n\tcompareHost?: DICompareHost<TModel> | null;\n}\n\n/**\n * `DICollectionControl` can be used to implement array controls (checkbox group, radio group, chips, etc.).\n * It has an additional integration with `DIStateControl` that allows you to use it as a host for\n * `DIStateControl` controls. If you use `DIStateControl` as a child control, then `DICollectionControl`\n * will update its model when the child control is checked or unchecked, so `DICollectionControl` will\n * contain only checked values.\n *\n * It also works with other controls, but their model should be an array.\n *\n * > **Warning**\n * > If child control model is updated with non-array value, then `DICollectionControl` will be updated with `null`.\n *\n * ## Creating a control\n * To create a control you need to extend your `@Component` or `@Directive` from `DICollectionControl` class.\n * After that your control will be able to work with `NgModel`, `FormControl`.\n *\n * ```ts fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DICollectionControl<string> {\n *   constructor() {\n *    super();\n *  }\n * }\n *  ```\n *\n * ## Registering as a host\n * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host\n * for another controls, then your control will be able to update them and accept updates from them. To do that you need to\n * use `provideHostControl` function.\n *\n * ```ts {2} fileName=\"custom-control.component.ts\"\n * @Component({\n *   providers: [provideHostControl(CustomControlComponent)],\n * })\n * export class CustomControlComponent extends DICollectionControl<string> {\n *   constructor() {\n *     super();\n *   }\n * }\n * ```\n *\n * ## Injecting host control\n * By default your control doesn't communicate with host controls. But you can inject host control and put it\n * into `super` call. This will register your control in the host control and start communication between them.\n *\n * > **Note**\n * > If you register your control as a host for another controls, then you can inject it\n * > only with `skipSelf` option.\n *\n * ```ts {5} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DICollectionControl<string> {\n *   constructor() {\n *     // we add `optional` option to make it possible to use this control without host\n *     super({host: injectHostControl({optional: true})});\n *   }\n * }\n * ```\n *\n * ## Getting model\n * To get model you need to use `model` property. It will return model for the current control.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DICollectionControl<string> {\n *   constructor() {\n *     super();\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     console.log(this.model());\n *   }\n * }\n * ```\n *\n * ## Updating model\n * To update model you need to call `updateModel` method. It will update model for the current control and all\n * children controls, as well as for the `NgModel` or `FormControl`.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DICollectionControl<string> {\n *   constructor() {\n *     super();\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     this.updateModel(['new value']);\n *   }\n * }\n * ```\n * ## Catching updates\n * Sometimes you may need to catch updates from different sources. For example, to update the value of the native\n * input element. To do this, you can provide the `onIncomingUpdate` hook.\n *\n * ```ts {6} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DICollectionControl<string> {\n *   constructor() {\n *     super({\n *       onIncomingUpdate: (value: string[] | null) => {\n *         this.elementRef.nativeElement.value = value;\n *       },\n *     });\n *   }\n * }\n * ```\n *\n * ## Comparing values\n * By default `DICollectionControl` uses `===` operator to compare values. It may be not enough for some cases,\n * for example, when you want to compare immutable objects. To solve this problem you can provide `compareFn`\n * function and provide your control as a `DICompareHost`. It will be used to compare values in the array.\n *\n * > **Warning**\n * > This function will be used by `DIStateControl` to compare values, to set checked state.\n * > Don't forget to inject `DICompareHost` in your `DIStateControl` to make it work.\n *\n * ```ts {2} fileName=\"custom-control.component.ts\"\n * @Component({\n *   providers: [provideCompareHost(CustomControlComponent)],\n * })\n * export class CustomControlComponent extends DICollectionControl<string> {\n *  constructor() {\n *    super()\n *  }\n * }\n * ```\n */\n@Directive()\nexport abstract class DICollectionControl<TModel>\n\textends DIControl<TModel[], TModel | TModel[]>\n\timplements DICompareHost<TModel>\n{\n\t/**\n\t * Function that will be used to compare values in the array.\n\t * Useful when you want to compare objects by some property (e.g. `id`).\n\t */\n\t@Input()\n\tcompareFn: DICompareFunction<TModel> = DI_DEFAULT_COMPARE;\n\n\tprivate proxyModel: SetCompare<TModel> = new SetCompare<TModel>();\n\n\tprotected constructor(protected override config?: DICollectionControlConfig<TModel, TModel | TModel[]>) {\n\t\tsuper(config);\n\t}\n\n\toverride updateModel(obj: TModel[] | null): void {\n\t\tthis.proxyModel = new SetCompare(this.compareFn, obj);\n\n\t\tsuper.updateModel(obj);\n\t}\n\n\toverride writeValue(value: TModel[] | null) {\n\t\tthis.proxyModel = new SetCompare(this.compareFn, value);\n\n\t\tsuper.writeValue(value);\n\t}\n\n\toverride writeValueFromHost(obj: TModel[] | null) {\n\t\tthis.proxyModel = new SetCompare(this.compareFn, obj);\n\n\t\tsuper.writeValueFromHost(obj);\n\t}\n\n\tprotected override childControlChange(\n\t\tcontrol: DIControl<TModel | TModel[]>,\n\t\tvalue: TModel[] | null,\n\t) {\n\t\tthis.updateFrom = control;\n\t\tthis.updateModel(this.getNewModel(control, value));\n\t\tthis.incomingUpdate && this.incomingUpdate(this.model());\n\t}\n\n\tprivate getNewModel(\n\t\tcontrol: DIControl<TModel | TModel[]>,\n\t\tupdates: TModel | TModel[] | null,\n\t): TModel[] | null {\n\t\tif (control instanceof DIStateControl) {\n\t\t\tcontrol.checked()\n\t\t\t\t? this.proxyModel.add(control.value)\n\t\t\t\t: this.proxyModel.delete(control.value);\n\t\t} else if (Array.isArray(updates)) {\n\t\t\tthis.proxyModel = new SetCompare<TModel>(this.compareFn, updates);\n\t\t} else {\n\t\t\tthis.proxyModel = new SetCompare<TModel>(this.compareFn);\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.proxyModel.toArray();\n\t}\n\n\tprotected override updateControl(control: DIControl<TModel | TModel[]>): void {\n\t\tif (control instanceof DIStateControl) {\n\t\t\tcontrol.writeValueFromHost(this.proxyModel.has(control.value) ? control.value : false);\n\t\t} else {\n\t\t\tcontrol.writeValueFromHost(this.model());\n\t\t}\n\t}\n}\n","import {Directive} from '@angular/core';\nimport {DIProxyControlGetValue, DIProxyControlSetValue} from 'di-controls/types';\nimport {DIControl, DIControlConfig} from './control';\n\n/**\n * Configuration for the `DIProxyControl`.\n */\nexport interface DIProxyControlConfig<TModel, TChildModel> extends DIControlConfig<TModel, TChildModel> {\n\t/**\n\t * Function that will be used to get value from the current object model and set it to the child control\n\t * when update is requested.\n\t */\n\tgetValue: DIProxyControlGetValue<TModel, TChildModel>;\n\t/**\n\t * Function that will be used to set value to the object model when child control value is changed.\n\t */\n\tsetValue: DIProxyControlSetValue<TModel, TChildModel>;\n}\n\n/**\n * `DIProxyControl` is very suitable.\n * It is typically used as a host and works exclusively with objects. It is\n * necessary to bind child controls to a specific property of the object,\n * thereby ensuring that they update only that specific property and not the\n * entire object as a whole. Please see `*DateRangePage`.\n *\n * ## Creating a control\n * To create a control you need to extend your `@Component` or `@Directive` from `DIProxyControl` class\n * and provide `getValue` and `setValue` functions that will be used to get and set value from the object\n * to the child control.\n *\n * ```ts fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIProxyControl<MyObject> {\n *   constructor() {\n *    super({\n *      getValue: (model) => model.objectProperty,\n *      setValue: (model, value) => ({...model, objectProperty: value}),\n *    });\n *  }\n * }\n *  ```\n *\n * ## Registering as a host\n * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host\n * for another controls, then your control will be able to update them and accept updates from them. To do that you need to\n * use `provideHostControl` function.\n *\n * ```ts {2} fileName=\"custom-control.component.ts\"\n * @Component({\n *   providers: [provideHostControl(CustomControlComponent)],\n * })\n * export class CustomControlComponent extends DIProxyControl<MyObject> {\n *   constructor() {\n *     super({\n *      getValue: (model) => model.objectProperty,\n *      setValue: (model, value) => ({...model, objectProperty: value}),\n *    });\n *   }\n * }\n * ```\n *\n * ## Injecting host control\n * By default your control doesn't communicate with host controls. But you can inject host control and put it\n * into `super` call. This will register your control in the host control and start communication between them.\n *\n * > **Note**\n * > If you register your control as a host for another controls, then you can inject it\n * > only with `skipSelf` option.\n *\n * ```ts {5} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIProxyControl<MyObject> {\n *   constructor() {\n *     // we add `optional` option to make it possible to use this control without host\n *     super({\n *       host: injectHostControl({optional: true}),\n *       getValue: (model) => model.objectProperty,\n *       setValue: (model, value) => ({...model, objectProperty: value}),\n *     });\n *   }\n * }\n * ```\n *\n * ## Getting model\n * To get model you need to use `model` property. It will return model for the current control.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIProxyControl<MyObject> {\n *   constructor() {\n *     super(\n *       getValue: (model) => model.objectProperty,\n *       setValue: (model, value) => ({...model, objectProperty: value}),\n *     );\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     console.log(this.model());\n *   }\n * }\n * ```\n *\n * ## Updating model\n * To update model you need to call `updateModel` method. It will update model for the current control and all\n * children controls, as well as for the `NgModel` or `FormControl`.\n *\n * ```ts {9} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIProxyControl<MyObject> {\n *   constructor() {\n *     super(\n *       getValue: (model) => model.objectProperty,\n *       setValue: (model, value) => ({...model, objectProperty: value}),\n *     );\n *   }\n *\n *   @HostListener('click')\n *   onClick() {\n *     this.updateModel({objectProperty: 'new value'});\n *   }\n * }\n * ```\n * ## Catching updates\n * Sometimes you may need to catch updates from different sources. For example, to update the value of the native\n * input element. To do this, you can provide the `onIncomingUpdate` hook.\n *\n * ```ts {6} fileName=\"custom-control.component.ts\"\n * @Component({})\n * export class CustomControlComponent extends DIProxyControl<MyObject> {\n *   constructor() {\n *     super({\n *       onIncomingUpdate: (value: MyObject | null) => {\n *         this.elementRef.nativeElement.value = value;\n *       },\n *     });\n *   }\n * }\n * ```\n */\n@Directive()\nexport abstract class DIProxyControl<TModel, TChildModel> extends DIControl<TModel, TChildModel> {\n\tprotected constructor(\n\t\tprotected override config: DIProxyControlConfig<TModel, TChildModel>,\n\t) {\n\t\tsuper(config);\n\t}\n\n\toverride registerControl(control: DIControl<TChildModel>): void {\n\t\tthis.children.add(control);\n\n\t\t/*\n\t\t * We have to update control because its can be created dynamically.\n\t\t * We use Promise.resolve because NgModel uses it too to set first value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)\n\t\t * so there's no need to use angular life cycle hooks\n\t\t */\n\t\tPromise.resolve().then(() => control.writeValueFromHost(this.config.getValue(this.model())));\n\n\t\tcontrol.registerOnControlChange((value: TChildModel | null) => {\n\t\t\tthis.updateFrom = control;\n\t\t\tthis.updateModel(this.config.setValue(this.model(), value));\n\t\t});\n\n\t\tcontrol.registerRequestForUpdate(() => {\n\t\t\tcontrol.writeValueFromHost(this.config.getValue(this.model()));\n\t\t});\n\t}\n\n\tprotected override updateControl(control: DIControl<TChildModel>, value: TModel | null): void {\n\t\tcontrol.writeValueFromHost(this.config.getValue(value));\n\t}\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;;AAcA;;AAEG;AACH,MACsB,sBAAsB,CAAA;AAWF,IAAA,cAAA,CAAA;AAVtB,IAAA,KAAK,GAAqB,MAAM,CAAC,IAAI,CAAC,CAAC;AACvC,IAAA,SAAS,CAAmB;AAC5B,IAAA,UAAU,GAA4B,MAAM,CAAC,UAAU,CAAC,CAAC;AACzD,IAAA,iBAAiB,CAAoB;AACrC,IAAA,QAAQ,GAAc,MAAM,CAAC,SAAS,CAAC,CAAC;AACxC,IAAA,aAAa,GAA4B,MAAM,CAAC,KAAK,CAAC,CAAC;IAEhE,KAAK,GAAe,cAAc,CAAC;IACnC,MAAM,GAA8B,cAAc,CAAC;AAE7D,IAAA,WAAA,CAAyC,cAA0C,EAAA;QAA1C,IAAc,CAAA,cAAA,GAAd,cAAc,CAA4B;AAClF,QAAA,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;AACnE,QAAA,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC;QAEnD,IAAI,IAAI,CAAC,SAAS,EAAE;AACnB,YAAA,IAAI,CAAC,SAAS,CAAC,aAAa,GAAG,IAAI,CAAC;AACpC,SAAA;KACD;AAED;;AAEG;AACH,IAAA,IAAI,QAAQ,GAAA;AACX,QAAA,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;KAC9B;AAED;;AAEG;AACH,IAAA,IACI,QAAQ,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;KAC5B;IAED,IAAI,QAAQ,CAAC,UAAmB,EAAA;AAC/B,QAAA,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;KAClC;AAED;;;;;AAKG;AACH,IAAA,gBAAgB,CAAC,EAA6B,EAAA;AAC7C,QAAA,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;KACjB;AAED;;;;;AAKG;AACH,IAAA,iBAAiB,CAAC,EAAc,EAAA;AAC/B,QAAA,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;KAChB;AAED;;;;;AAKG;AACH,IAAA,UAAU,CAAC,GAAa,EAAA;AACvB,QAAA,IAAI,IAAI,CAAC,KAAK,EAAE,KAAK,GAAG,EAAE;AACzB,YAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACjB,SAAA;KACD;AAED;;;;AAIG;AACH,IAAA,WAAW,CAAC,KAAe,EAAA;AACzB,QAAA,IAAI,CAAC,KAAkC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACpD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;AAC1B,QAAA,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,CAAC;KACtC;AAED;;;;;AAKG;AACH,IAAA,gBAAgB,CAAC,UAAmB,EAAA;AACnC,QAAA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAEnC,IAAI,CAAC,aAAa,EAAE;AACnB,cAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,UAAU,EAAE,MAAM,CAAC;AAC/E,cAAE,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;QAC5E,IAAI,CAAC,QAAQ,CAAC,YAAY,CACzB,IAAI,CAAC,UAAU,CAAC,aAAa,EAC7B,eAAe,EACf,GAAG,IAAI,CAAC,aAAa,EAAE,CAAA,CAAE,CACzB,CAAC;KACF;AAEO,IAAA,MAAM,CAAC,KAAe,EAAA;AAC5B,QAAA,IAAI,CAAC,KAAkC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACpD,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AAClD,QAAA,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,CAAC;KACtC;uGAzGoB,sBAAsB,EAAA,IAAA,EAAA,SAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;2FAAtB,sBAAsB,EAAA,MAAA,EAAA,EAAA,QAAA,EAAA,UAAA,EAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;;2FAAtB,sBAAsB,EAAA,UAAA,EAAA,CAAA;kBAD3C,SAAS;6FAgCL,QAAQ,EAAA,CAAA;sBADX,KAAK;;;ACpBP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsGG;AACH,MACsB,SACpB,SAAQ,sBAA8B,CAAA;AAkCG,IAAA,MAAA,CAAA;AA/BzC;;;;;AAKG;AACO,IAAA,QAAQ,GAAgC,IAAI,GAAG,EAA0B,CAAC;AACpF;;;;;AAKG;IACO,UAAU,GAAkC,IAAI,CAAC;AAE3D;;;;;;AAMG;IACO,gBAAgB,GAAe,cAAc,CAAC;AACxD;;AAEG;AACgB,IAAA,KAAK,GAAe,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;IAEhE,iBAAiB,GAAmC,cAAc,CAAC;AACnE,IAAA,UAAU,GAAe,MAAM,CAAC,UAAU,CAAC,CAAC;AAEpD,IAAA,WAAA,CAAyC,MAA6C,EAAA;AACpF,QAAA,KAAK,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;QADO,IAAM,CAAA,MAAA,GAAN,MAAM,CAAuC;AAGpF,QAAA,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;KAC7E;IAED,QAAQ,GAAA;AACN;;;AAGG;QACH,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;KACxE;AAED;;;;;AAKG;AACH,IAAA,eAAe,CAAC,OAA+B,EAAA;AAC7C,QAAA,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AAE3B;;;;AAIG;AACH,QAAA,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAK;YAC1B,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;AAC5C,SAAC,CAAC,CAAC;AAEH,QAAA,OAAO,CAAC,uBAAuB,CAAC,CAAC,KAAqB,KAAI;AACxD,YAAA,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,KAAsB,CAAC,CAAC;YACzD,IAAI,CAAC,MAAM,EAAE,oBAAoB,GAAG,OAAO,EAAE,KAAsB,CAAC,CAAC;AACvE,SAAC,CAAC,CAAC;AAEH,QAAA,OAAO,CAAC,wBAAwB,CAAC,MAAK;YACpC,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;AAC5C,SAAC,CAAC,CAAC;KACJ;AAED;;;;;AAKG;AACH,IAAA,iBAAiB,CAAC,OAA+B,EAAA;AAC/C,QAAA,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;KAC/B;AAEQ,IAAA,iBAAiB,CAAC,EAAc,EAAA;AACvC,QAAA,IAAI,CAAC,KAAK,GAAG,MAAK;AAChB,YAAA,EAAE,EAAE,CAAC;;AAGL,YAAA,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;AAC7B,SAAC,CAAC;KACH;AAED;;;;;;AAMG;AACH,IAAA,uBAAuB,CAAC,EAAkC,EAAA;AACxD,QAAA,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;KAC7B;AAED;;;;;;;AAOG;AACH,IAAA,wBAAwB,CAAC,EAAc,EAAA;AACrC,QAAA,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;KAC5B;AAED;;;;;AAKG;AACM,IAAA,WAAW,CAAC,KAAoB,EAAA;AACvC,QAAA,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;AACzB,QAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;QAC9B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;KACnC;AAEQ,IAAA,UAAU,CAAC,KAAoB,EAAA;AACtC,QAAA,IAAI,IAAI,CAAC,KAAK,EAAE,KAAK,KAAK,EAAE;AAC1B,YAAA,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACxB,YAAA,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AAC3B,YAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAA;KACF;AAED;;;;;AAKG;AACH,IAAA,kBAAkB,CAAC,KAAoB,EAAA;AACrC,QAAA,IAAI,IAAI,CAAC,KAAK,EAAE,KAAK,KAAK,EAAE;AAC1B,YAAA,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACxB,YAAA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACnB,YAAA,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AAC5B,SAAA;KACF;AAED;;;;;;AAMG;AACO,IAAA,cAAc,CAAC,KAAoB,EAAA;QAC3C,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAA+B,KAAI;AACxD,YAAA,IAAI,OAAO,KAAK,IAAI,CAAC,UAAU,EAAE;AAC/B,gBAAA,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACpC,aAAA;AACH,SAAC,CAAC,CAAC;AACH,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KACxB;AAED;;;;;;;AAOG;IACO,aAAa,CAAC,OAA+B,EAAE,KAAoB,EAAA;AAC3E,QAAA,OAAO,CAAC,kBAAkB,CAAC,KAAoB,CAAC,CAAC;KAClD;AAED;;;;;;;AAOG;IACO,kBAAkB,CAAC,OAA+B,EAAE,KAAoB,EAAA;AAChF,QAAA,IAAI,IAAI,CAAC,KAAK,EAAE,KAAK,KAAK,EAAE;AAC1B,YAAA,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;AAC1B,YAAA,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YACxB,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AACnD,SAAA;KACF;uGAnMmB,SAAS,EAAA,IAAA,EAAA,SAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;2FAAT,SAAS,EAAA,eAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;;2FAAT,SAAS,EAAA,UAAA,EAAA,CAAA;kBAD9B,SAAS;;;AC/GV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkLG;AACH,MACsB,cACrB,SAAQ,SAA2B,CAAA;AAcN,IAAA,MAAA,CAAA;IAV7B,KAAK,GAAkB,IAAI,CAAC;AAE5B,IAAA,OAAO,GAA2B,QAAQ,CAAC,MAAK;QAC/C,MAAM,SAAS,GACd,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,IAAI,kBAAkB,CAAC;AAE3D,QAAA,OAAO,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,KAAK,CAAC;AACxF,KAAC,CAAC,CAAC;AAEH,IAAA,WAAA,CAC6B,MAA+C,EAAA;QAE3E,KAAK,CAAC,MAAM,CAAC,CAAC;QAFc,IAAM,CAAA,MAAA,GAAN,MAAM,CAAyC;;QAK3E,MAAM,CAAC,MAAK;AACX,YAAA,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,IAAI,GAAG,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;AAEvE,YAAA,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,cAAc,EAAE,GAAG,WAAW,CAAA,CAAE,CAAC,CAAC;AAC7F,SAAC,CAAC,CAAC;KACH;IAED,WAAW,CAAC,EAAE,KAAK,EAAiB,EAAA;AACnC;;;;AAIG;AACH,QAAA,IAAI,KAAK,EAAE;YACV,IAAI,CAAC,gBAAgB,EAAE,CAAC;AACxB,SAAA;KACD;;IAGD,KAAK,GAAA;AACJ,QAAA,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC7B;;IAGD,OAAO,GAAA;AACN,QAAA,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;KACxB;;IAGD,YAAY,GAAA;AACX,QAAA,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KACvB;;IAGD,MAAM,GAAA;QACL,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;KAChE;AAED,IAAA,IAAI,cAAc,GAAA;AACjB,QAAA,OAAO,IAAI,CAAC,KAAK,EAAE,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,eAAe,CAAC;KAC/D;uGA5DoB,cAAc,EAAA,IAAA,EAAA,SAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;2FAAd,cAAc,EAAA,MAAA,EAAA,EAAA,KAAA,EAAA,OAAA,EAAA,EAAA,eAAA,EAAA,IAAA,EAAA,aAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;;2FAAd,cAAc,EAAA,UAAA,EAAA,CAAA;kBADnC,SAAS;mBAAC,EAAE,CAAA;6FAMZ,KAAK,EAAA,CAAA;sBADJ,KAAK;;;AC1LP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiIG;AACH,MACsB,mBACrB,SAAQ,SAAsC,CAAA;AAYL,IAAA,MAAA,CAAA;AATzC;;;AAGG;IAEH,SAAS,GAA8B,kBAAkB,CAAC;AAElD,IAAA,UAAU,GAAuB,IAAI,UAAU,EAAU,CAAC;AAElE,IAAA,WAAA,CAAyC,MAA6D,EAAA;QACrG,KAAK,CAAC,MAAM,CAAC,CAAC;QAD0B,IAAM,CAAA,MAAA,GAAN,MAAM,CAAuD;KAErG;AAEQ,IAAA,WAAW,CAAC,GAAoB,EAAA;AACxC,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;AAEtD,QAAA,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;KACvB;AAEQ,IAAA,UAAU,CAAC,KAAsB,EAAA;AACzC,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;AAExD,QAAA,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;KACxB;AAEQ,IAAA,kBAAkB,CAAC,GAAoB,EAAA;AAC/C,QAAA,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;AAEtD,QAAA,KAAK,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;KAC9B;IAEkB,kBAAkB,CACpC,OAAqC,EACrC,KAAsB,EAAA;AAEtB,QAAA,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;AAC1B,QAAA,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;AACnD,QAAA,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;KACzD;IAEO,WAAW,CAClB,OAAqC,EACrC,OAAiC,EAAA;QAEjC,IAAI,OAAO,YAAY,cAAc,EAAE;YACtC,OAAO,CAAC,OAAO,EAAE;kBACd,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC;kBAClC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACzC,SAAA;AAAM,aAAA,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;AAClC,YAAA,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU,CAAS,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AAClE,SAAA;AAAM,aAAA;YACN,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU,CAAS,IAAI,CAAC,SAAS,CAAC,CAAC;AAEzD,YAAA,OAAO,IAAI,CAAC;AACZ,SAAA;AAED,QAAA,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;KACjC;AAEkB,IAAA,aAAa,CAAC,OAAqC,EAAA;QACrE,IAAI,OAAO,YAAY,cAAc,EAAE;YACtC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;AACvF,SAAA;AAAM,aAAA;YACN,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;AACzC,SAAA;KACD;uGArEoB,mBAAmB,EAAA,IAAA,EAAA,SAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;2FAAnB,mBAAmB,EAAA,MAAA,EAAA,EAAA,SAAA,EAAA,WAAA,EAAA,EAAA,eAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;;2FAAnB,mBAAmB,EAAA,UAAA,EAAA,CAAA;kBADxC,SAAS;6FAUT,SAAS,EAAA,CAAA;sBADR,KAAK;;;AC1IP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyHG;AACH,MACsB,cAAoC,SAAQ,SAA8B,CAAA;AAE3E,IAAA,MAAA,CAAA;AADpB,IAAA,WAAA,CACoB,MAAiD,EAAA;QAEpE,KAAK,CAAC,MAAM,CAAC,CAAC;QAFK,IAAM,CAAA,MAAA,GAAN,MAAM,CAA2C;KAGpE;AAEQ,IAAA,eAAe,CAAC,OAA+B,EAAA;AACvD,QAAA,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AAE3B;;;;AAIG;QACH,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;AAE7F,QAAA,OAAO,CAAC,uBAAuB,CAAC,CAAC,KAAyB,KAAI;AAC7D,YAAA,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC;AAC1B,YAAA,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;AAC7D,SAAC,CAAC,CAAC;AAEH,QAAA,OAAO,CAAC,wBAAwB,CAAC,MAAK;AACrC,YAAA,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AAChE,SAAC,CAAC,CAAC;KACH;IAEkB,aAAa,CAAC,OAA+B,EAAE,KAAoB,EAAA;AACrF,QAAA,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;KACxD;uGA7BoB,cAAc,EAAA,IAAA,EAAA,SAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;2FAAd,cAAc,EAAA,eAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;;2FAAd,cAAc,EAAA,UAAA,EAAA,CAAA;kBADnC,SAAS;;;AC7IV;;AAEG;;;;"}