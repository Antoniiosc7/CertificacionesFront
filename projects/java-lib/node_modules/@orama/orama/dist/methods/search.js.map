{"version":3,"sources":["../../src/methods/search.ts"],"sourcesContent":["import { prioritizeTokenScores } from '../components/algorithms.js'\nimport { getFacets } from '../components/facets.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { createError } from '../errors.js'\nimport {\n  BM25Params,\n  IndexMap,\n  Orama,\n  Result,\n  Results,\n  SearchContext,\n  SearchParams,\n  TokenMap,\n  ElapsedTime,\n  IIndex,\n  Tokenizer,\n  IDocumentsStore,\n  CustomSorterFunctionItem,\n  OpaqueIndex,\n  OpaqueDocumentStore,\n} from '../types.js'\nimport { getNanosecondsTime, sortTokenScorePredicate } from '../utils.js'\n\nconst defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5,\n}\n\nasync function createSearchContext<I extends OpaqueIndex, D extends OpaqueDocumentStore>(\n  tokenizer: Tokenizer,\n  index: IIndex<I>,\n  documentsStore: IDocumentsStore<D>,\n  language: string | undefined,\n  params: SearchParams,\n  properties: string[],\n  tokens: string[],\n  docsCount: number,\n): Promise<SearchContext<I, D>> {\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  // let whereFiltersIDs: string[] = [];\n\n  // if (hasFilters) {\n  //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n  // }\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {}\n\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {}\n\n  for (const prop of properties) {\n    const tokensMap: TokenMap = {}\n    for (const token of tokens) {\n      tokensMap[token] = []\n    }\n    indexMap[prop] = tokensMap\n    docsIntersection[prop] = []\n  }\n\n  return {\n    timeStart: await getNanosecondsTime(),\n    tokenizer,\n    index,\n    documentsStore,\n    language,\n    params,\n    docsCount,\n    uniqueDocsIDs: {},\n    indexMap,\n    docsIntersection,\n  }\n}\n\nexport async function search(orama: Orama, params: SearchParams, language?: string): Promise<Results> {\n  params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params)\n\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n  const { limit = 10, offset = 0, term, properties, threshold = 1 } = params\n  const isPreflight = params.preflight === true\n\n  const { index, docs } = orama.data\n  const tokens = await orama.tokenizer.tokenize(term ?? '', language)\n\n  // Get searchable string properties\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string'),\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (properties && properties !== '*') {\n    for (const prop of properties) {\n      if (!propertiesToSearch.includes(prop)) {\n        throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => properties.includes(prop))\n  }\n\n  // Create the search context and the results\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n  )\n  const results: Result[] = Array.from({\n    length: limit,\n  })\n\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  let whereFiltersIDs: string[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n  }\n\n  if (tokens.length) {\n    // Now it's time to loop over all the indices and get the documents IDs for every single term\n    const indexesLength = propertiesToSearch.length\n    for (let i = 0; i < indexesLength; i++) {\n      const prop = propertiesToSearch[i]\n\n      const tokensLength = tokens.length\n      for (let j = 0; j < tokensLength; j++) {\n        const term = tokens[j]\n\n        // Lookup\n        const scoreList = await orama.index.search(context, index, prop, term)\n\n        context.indexMap[prop][term].push(...scoreList)\n      }\n\n      const docIds = context.indexMap[prop]\n      const vals = Object.values(docIds)\n      context.docsIntersection[prop] = prioritizeTokenScores(vals, params?.boost?.[prop] ?? 1, threshold)\n      const uniqueDocs = context.docsIntersection[prop]\n\n      const uniqueDocsLength = uniqueDocs.length\n      for (let i = 0; i < uniqueDocsLength; i++) {\n        const [id, score] = uniqueDocs[i]\n\n        const prevScore = context.uniqueDocsIDs[id]\n        if (prevScore) {\n          context.uniqueDocsIDs[id] = prevScore + score + 0.5\n        } else {\n          context.uniqueDocsIDs[id] = score\n        }\n      }\n    }\n  } else if (tokens.length === 0 && term) {\n    // This case is hard to handle correctly.\n    // For the time being, if tokenizer returns empty array but the term is not empty,\n    // we returns an empty result set\n    context.uniqueDocsIDs = {}\n  } else {\n    context.uniqueDocsIDs = Object.fromEntries(\n      Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map(k => [k, 0]),\n    )\n  }\n\n  // Get unique doc IDs from uniqueDocsIDs map\n  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs)\n\n  // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n  if (hasFilters) {\n    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray)\n  }\n\n  if (params.sortBy) {\n    if (typeof params.sortBy === 'function') {\n      const ids: string[] = uniqueDocsArray.map(([id]) => id)\n      const docs = await orama.documentsStore.getMultiple(orama.data.docs, ids)\n      const docsWithIdAndScore: CustomSorterFunctionItem[] = docs.map((d, i) => [\n        uniqueDocsArray[i][0],\n        uniqueDocsArray[i][1],\n        d!,\n      ])\n      docsWithIdAndScore.sort(params.sortBy)\n      uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score])\n    } else {\n      uniqueDocsArray = await orama.sorter.sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)\n    }\n  } else {\n    uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate)\n  }\n\n  const resultIDs: Set<string> = new Set()\n  if (!isPreflight) {\n    // We already have the list of ALL the document IDs containing the search terms.\n    // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n    // to provide pagination capabilities to the search.\n    for (let i = offset; i < limit + offset; i++) {\n      const idAndScore = uniqueDocsArray[i]\n\n      // If there are no more results, just break the loop\n      if (typeof idAndScore === 'undefined') {\n        break\n      }\n\n      const [id, score] = idAndScore\n\n      if (!resultIDs.has(id)) {\n        // We retrieve the full document only AFTER making sure that we really want it.\n        // We never retrieve the full document preventively.\n        const fullDoc = await orama.documentsStore.get(docs, id)\n        results[i] = { id, score, document: fullDoc! }\n        resultIDs.add(id)\n      }\n    }\n  }\n\n  const searchResult: Results = {\n    elapsed: (await orama.formatElapsedTime((await getNanosecondsTime()) - context.timeStart)) as ElapsedTime,\n    // We keep the hits array empty if it's a preflight request.\n    hits: [],\n    count: uniqueDocsArray.length,\n  }\n\n  if (!isPreflight) {\n    searchResult.hits = results.filter(Boolean)\n  }\n\n  if (shouldCalculateFacets) {\n    // Populate facets if needed\n    const facets = await getFacets(orama, uniqueDocsArray, params.facets!)\n    searchResult.facets = facets\n  }\n\n  return searchResult\n}\n"],"names":["prioritizeTokenScores","getFacets","intersectFilteredIDs","createError","getNanosecondsTime","sortTokenScorePredicate","defaultBM25Params","k","b","d","createSearchContext","tokenizer","index","documentsStore","language","params","properties","tokens","docsCount","indexMap","docsIntersection","prop","tokensMap","token","timeStart","uniqueDocsIDs","search","orama","relevance","Object","assign","shouldCalculateFacets","facets","keys","length","limit","offset","term","threshold","isPreflight","preflight","docs","data","tokenize","propertiesToSearch","caches","propertiesToSearchWithTypes","getSearchablePropertiesWithTypes","getSearchableProperties","filter","startsWith","includes","join","context","count","results","Array","from","hasFilters","where","whereFiltersIDs","searchByWhereClause","indexesLength","i","tokensLength","j","scoreList","push","docIds","vals","values","boost","uniqueDocs","uniqueDocsLength","id","score","prevScore","fromEntries","getAll","map","uniqueDocsArray","entries","sortBy","ids","getMultiple","docsWithIdAndScore","sort","sorter","sorting","resultIDs","Set","idAndScore","has","fullDoc","get","document","add","searchResult","elapsed","formatElapsedTime","hits","Boolean"],"mappings":"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"}