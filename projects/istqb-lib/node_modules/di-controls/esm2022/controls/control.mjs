import { DestroyRef, Directive, inject } from '@angular/core';
import { DIControlValueAccessor } from './control-value-accessor';
import { EMPTY_FUNCTION } from 'di-controls/constants';
import * as i0 from "@angular/core";
/**
 * `DIControl` can be used to implement any control that you want. It can work with any model type.
 * All updates from children will be accepted as is. And updates from outside (`FormControl`, `NgModel`, another Control)
 * will be accepted as is too.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DIControl` class.
 * After that your control will be able to work with `NgModel`, `FormControl`.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *    super();
 *  }
 * }
 *  ```
 *
 * ## Registering as a host
 * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host
 * for another controls, then your control will be able to update them and accept updates from them. To do that you need to
 * use `provideHostControl` function.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideHostControl(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *   }
 * }
 * ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({host: injectHostControl({optional: true})});
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.model());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you need to call `updateModel` method. It will update model for the current control and all
 * children controls, as well as for the `NgModel` or `FormControl`.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.updateModel('new value');
 *   }
 * }
 * ```
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: string | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 */
class DIControl extends DIControlValueAccessor {
    config;
    /**
     * List of children controls.
     *
     * @protected
     * @internal
     */
    children = new Set();
    /**
     * Control from which we have to update our model.
     *
     * @protected
     * @internal
     */
    updateFrom = null;
    /**
     * Request host for update the current control.
     * Host will update the current control based on its current state and host control logic.
     *
     * @protected
     * @internal
     */
    requestForUpdate = EMPTY_FUNCTION;
    /**
     * Function that should be used to make control touched.
     */
    touch = () => this.config?.host?.touch();
    onControlChangeFn = EMPTY_FUNCTION;
    destroyRef = inject(DestroyRef);
    constructor(config) {
        super(config?.onIncomingUpdate);
        this.config = config;
        this.destroyRef.onDestroy(() => this.config?.host?.unregisterControl(this));
    }
    ngOnInit() {
        /*
         * We have to register control with Promise.resolve because NgModel uses it too to set first
         * value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)
         */
        Promise.resolve().then(() => this.config?.host?.registerControl(this));
    }
    /**
     * Registers provided control as a child of the current control.
     *
     * @param control - control that will be registered.
     * @internal
     */
    registerControl(control) {
        this.children.add(control);
        /*
         * We have to update control because its can be created dynamically.
         * We use Promise.resolve because NgModel uses it too to set first value (https://github.com/angular/angular/blob/7df9127088bda3c9d29937a04287b87dc2045ea7/packages/forms/src/directives/ng_model.ts#L314)
         * so there's no need to use angular life cycle hooks
         */
        Promise.resolve().then(() => {
            this.updateControl(control, this.model());
        });
        control.registerOnControlChange((value) => {
            this.childControlChange(control, value);
            this.config?.onChildControlChange?.(control, value);
        });
        control.registerRequestForUpdate(() => {
            this.updateControl(control, this.model());
        });
    }
    /**
     * Unregisters provided control from the current control.
     *
     * @param control - control that will be unregistered.
     * @internal
     */
    unregisterControl(control) {
        this.children.delete(control);
    }
    registerOnTouched(fn) {
        this.touch = () => {
            fn();
            // Touch host control to update its state
            this.config?.host?.touch();
        };
    }
    /**
     * Registers provided function as a callback that will be called when the current control changes.
     * This function will be provided by the host control to update its model.
     *
     * @param fn - callback function.
     * @internal
     */
    registerOnControlChange(fn) {
        this.onControlChangeFn = fn;
    }
    /**
     * Registers provided function as a callback that can be called to request an update from the host control.
     * After calling this function the host control will update the model of the current control based on the current
     * state of the control and host control logic.
     *
     * @param fn - callback function.
     * @internal
     */
    registerRequestForUpdate(fn) {
        this.requestForUpdate = fn;
    }
    /**
     * Updates the model of the current control.
     * This is the main method that should be used to update the model.
     *
     * @param value - new value.
     */
    updateModel(value) {
        super.updateModel(value);
        this.onControlChangeFn(value);
        this.updateControls(this.model());
    }
    writeValue(value) {
        if (this.model() !== value) {
            super.writeValue(value);
            this.updateControls(value);
            this.onControlChangeFn(value);
        }
    }
    /**
     * Method is called by the host to update the value of the control.
     *
     * @param value - new value
     * @internal
     */
    writeValueFromHost(value) {
        if (this.model() !== value) {
            super.writeValue(value);
            this.change(value);
            this.updateControls(value);
        }
    }
    /**
     * Updates all child controls with the provided value.
     *
     * @param value - new value.
     * @protected
     * @internal
     */
    updateControls(value) {
        this.children.forEach((control) => {
            if (control !== this.updateFrom) {
                this.updateControl(control, value);
            }
        });
        this.updateFrom = null;
    }
    /**
     * Updates provided control with the provided value.
     *
     * @param control - control that will be updated.
     * @param value - new value.
     * @protected
     * @internal
     */
    updateControl(control, value) {
        control.writeValueFromHost(value);
    }
    /**
     * Function catches updates from child controls and updates the current control model.
     *
     * @param control - control that was updated.
     * @param value - new value.
     * @protected
     * @internal
     */
    childControlChange(control, value) {
        if (this.model() !== value) {
            this.updateFrom = control;
            this.updateModel(value);
            this.incomingUpdate && this.incomingUpdate(value);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIControl, usesInheritance: true, ngImport: i0 });
}
export { DIControl };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControl, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvZGktY29udHJvbHMvY29udHJvbHMvY29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDdEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztBQTBCdkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNHRztBQUNILE1BQ3NCLFNBQ3BCLFNBQVEsc0JBQThCO0lBa0NHO0lBL0J6Qzs7Ozs7T0FLRztJQUNPLFFBQVEsR0FBZ0MsSUFBSSxHQUFHLEVBQTBCLENBQUM7SUFDcEY7Ozs7O09BS0c7SUFDTyxVQUFVLEdBQWtDLElBQUksQ0FBQztJQUUzRDs7Ozs7O09BTUc7SUFDTyxnQkFBZ0IsR0FBZSxjQUFjLENBQUM7SUFDeEQ7O09BRUc7SUFDZ0IsS0FBSyxHQUFlLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDO0lBRWhFLGlCQUFpQixHQUFtQyxjQUFjLENBQUM7SUFDbkUsVUFBVSxHQUFlLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVwRCxZQUF5QyxNQUE2QztRQUNwRixLQUFLLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFETyxXQUFNLEdBQU4sTUFBTSxDQUF1QztRQUdwRixJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxp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SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sY0FBYyxDQUFDLEtBQW9CO1FBQzNDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBK0IsRUFBRSxFQUFFO1lBQ3hELElBQUksT0FBTyxLQUFLLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQy9CLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3BDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNPLGFBQWEsQ0FBQyxPQUErQixFQUFFLEtBQW9CO1FBQzNFLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFvQixDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDTyxrQkFBa0IsQ0FBQyxPQUErQixFQUFFLEtBQW9CO1FBQ2hGLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEtBQUssRUFBRTtZQUMxQixJQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQztZQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuRDtJQUNILENBQUM7dUdBbk1tQixTQUFTOzJGQUFULFNBQVM7O1NBQVQsU0FBUzsyRkFBVCxTQUFTO2tCQUQ5QixTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVzdHJveVJlZiwgRGlyZWN0aXZlLCBpbmplY3QsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRElDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJy4vY29udHJvbC12YWx1ZS1hY2Nlc3Nvcic7XG5pbXBvcnQgeyBFTVBUWV9GVU5DVElPTiB9IGZyb20gJ2RpLWNvbnRyb2xzL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIGBESUNvbnRyb2xgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERJQ29udHJvbENvbmZpZzxUTW9kZWwsIFRDaGlsZE1vZGVsPiB7XG4gIC8qKlxuICAgKiBIb3N0IGNvbnRyb2wgZm9yIHRoZSBjdXJyZW50IGNvbnRyb2wuIEl0IGNhbiBiZSBpbmplY3RlZCB1c2luZyBgRElfSE9TVF9DT05UUk9MYCB0b2tlbi5cbiAgICovXG4gIGhvc3Q/OiBESUNvbnRyb2w8YW55LCBUTW9kZWw+IHwgbnVsbDtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY3VycmVudCBjb250cm9sIHJlY2VpdmVzIGFuIHVwZGF0ZSBmcm9tIHRoZSBob3N0IGNvbnRyb2wgb3IgZnJvbSB0aGVcbiAgICogRm9ybXMgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBuZXcgdmFsdWUuXG4gICAqL1xuICBvbkluY29taW5nVXBkYXRlPzogKHZhbHVlOiBUTW9kZWwgfCBudWxsKSA9PiB2b2lkO1xuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjdXJyZW50IGNvbnRyb2wgcmVjZWl2ZXMgYW4gdXBkYXRlIGZyb20gdGhlIGNoaWxkIGNvbnRyb2wuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cm9sIC0gY2hpbGQgY29udHJvbCB0aGF0IHdhcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBuZXcgdmFsdWUuXG4gICAqL1xuICBvbkNoaWxkQ29udHJvbENoYW5nZT86IChjb250cm9sOiBESUNvbnRyb2w8VENoaWxkTW9kZWw+LCB2YWx1ZTogVE1vZGVsIHwgbnVsbCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBgRElDb250cm9sYCBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgYW55IGNvbnRyb2wgdGhhdCB5b3Ugd2FudC4gSXQgY2FuIHdvcmsgd2l0aCBhbnkgbW9kZWwgdHlwZS5cbiAqIEFsbCB1cGRhdGVzIGZyb20gY2hpbGRyZW4gd2lsbCBiZSBhY2NlcHRlZCBhcyBpcy4gQW5kIHVwZGF0ZXMgZnJvbSBvdXRzaWRlIChgRm9ybUNvbnRyb2xgLCBgTmdNb2RlbGAsIGFub3RoZXIgQ29udHJvbClcbiAqIHdpbGwgYmUgYWNjZXB0ZWQgYXMgaXMgdG9vLlxuICpcbiAqICMjIENyZWF0aW5nIGEgY29udHJvbFxuICogVG8gY3JlYXRlIGEgY29udHJvbCB5b3UgbmVlZCB0byBleHRlbmQgeW91ciBgQENvbXBvbmVudGAgb3IgYEBEaXJlY3RpdmVgIGZyb20gYERJQ29udHJvbGAgY2xhc3MuXG4gKiBBZnRlciB0aGF0IHlvdXIgY29udHJvbCB3aWxsIGJlIGFibGUgdG8gd29yayB3aXRoIGBOZ01vZGVsYCwgYEZvcm1Db250cm9sYC5cbiAqXG4gKiBgYGB0cyBmaWxlTmFtZT1cImN1c3RvbS1jb250cm9sLmNvbXBvbmVudC50c1wiXG4gKiBAQ29tcG9uZW50KHt9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBESUNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgc3VwZXIoKTtcbiAqICB9XG4gKiB9XG4gKiAgYGBgXG4gKlxuICogIyMgUmVnaXN0ZXJpbmcgYXMgYSBob3N0XG4gKiBCeSBkZWZhdWx0IHlvdXIgY29udHJvbCBjYW4gd29yayBvbmx5IHdpdGggYE5nTW9kZWxgIGFuZCBgRm9ybUNvbnRyb2xgLiBCdXQgeW91IGNhbiByZWdpc3RlciB5b3VyIGNvbnRyb2wgYXMgYSBob3N0XG4gKiBmb3IgYW5vdGhlciBjb250cm9scywgdGhlbiB5b3VyIGNvbnRyb2wgd2lsbCBiZSBhYmxlIHRvIHVwZGF0ZSB0aGVtIGFuZCBhY2NlcHQgdXBkYXRlcyBmcm9tIHRoZW0uIFRvIGRvIHRoYXQgeW91IG5lZWQgdG9cbiAqIHVzZSBgcHJvdmlkZUhvc3RDb250cm9sYCBmdW5jdGlvbi5cbiAqXG4gKiBgYGB0cyB7Mn0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7XG4gKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVIb3N0Q29udHJvbChDdXN0b21Db250cm9sQ29tcG9uZW50KV0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBESUNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIEluamVjdGluZyBob3N0IGNvbnRyb2xcbiAqIEJ5IGRlZmF1bHQgeW91ciBjb250cm9sIGRvZXNuJ3QgY29tbXVuaWNhdGUgd2l0aCBob3N0IGNvbnRyb2xzLiBCdXQgeW91IGNhbiBpbmplY3QgaG9zdCBjb250cm9sIGFuZCBwdXQgaXRcbiAqIGludG8gYHN1cGVyYCBjYWxsLiBUaGlzIHdpbGwgcmVnaXN0ZXIgeW91ciBjb250cm9sIGluIHRoZSBob3N0IGNvbnRyb2wgYW5kIHN0YXJ0IGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGVtLlxuICpcbiAqID4gKipOb3RlKipcbiAqID4gSWYgeW91IHJlZ2lzdGVyIHlvdXIgY29udHJvbCBhcyBhIGhvc3QgZm9yIGFub3RoZXIgY29udHJvbHMsIHRoZW4geW91IGNhbiBpbmplY3QgaXRcbiAqID4gb25seSB3aXRoIGBza2lwU2VsZmAgb3B0aW9uLlxuICpcbiAqIGBgYHRzIHs1fSBmaWxlTmFtZT1cImN1c3RvbS1jb250cm9sLmNvbXBvbmVudC50c1wiXG4gKiBAQ29tcG9uZW50KHt9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBESUNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIC8vIHdlIGFkZCBgb3B0aW9uYWxgIG9wdGlvbiB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSB0aGlzIGNvbnRyb2wgd2l0aG91dCBob3N0XG4gKiAgICAgc3VwZXIoe2hvc3Q6IGluamVjdEhvc3RDb250cm9sKHtvcHRpb25hbDogdHJ1ZX0pfSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIEdldHRpbmcgbW9kZWxcbiAqIFRvIGdldCBtb2RlbCB5b3UgbmVlZCB0byB1c2UgYG1vZGVsYCBwcm9wZXJ0eS4gSXQgd2lsbCByZXR1cm4gbW9kZWwgZm9yIHRoZSBjdXJyZW50IGNvbnRyb2wuXG4gKlxuICogYGBgdHMgezl9IGZpbGVOYW1lPVwiY3VzdG9tLWNvbnRyb2wuY29tcG9uZW50LnRzXCJcbiAqIEBDb21wb25lbnQoe30pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tQ29udHJvbENvbXBvbmVudCBleHRlbmRzIERJQ29udHJvbDxzdHJpbmc+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoKTtcbiAqICAgfVxuICpcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICogICBvbkNsaWNrKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMubW9kZWwoKSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIFVwZGF0aW5nIG1vZGVsXG4gKiBUbyB1cGRhdGUgbW9kZWwgeW91IG5lZWQgdG8gY2FsbCBgdXBkYXRlTW9kZWxgIG1ldGhvZC4gSXQgd2lsbCB1cGRhdGUgbW9kZWwgZm9yIHRoZSBjdXJyZW50IGNvbnRyb2wgYW5kIGFsbFxuICogY2hpbGRyZW4gY29udHJvbHMsIGFzIHdlbGwgYXMgZm9yIHRoZSBgTmdNb2RlbGAgb3IgYEZvcm1Db250cm9sYC5cbiAqXG4gKiBgYGB0cyB7OX0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50IGV4dGVuZHMgRElDb250cm9sPHN0cmluZz4ge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcigpO1xuICogICB9XG4gKlxuICogICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gKiAgIG9uQ2xpY2soKSB7XG4gKiAgICAgdGhpcy51cGRhdGVNb2RlbCgnbmV3IHZhbHVlJyk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogIyMgQ2F0Y2hpbmcgdXBkYXRlc1xuICogU29tZXRpbWVzIHlvdSBtYXkgbmVlZCB0byBjYXRjaCB1cGRhdGVzIGZyb20gZGlmZmVyZW50IHNvdXJjZXMuIEZvciBleGFtcGxlLCB0byB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBuYXRpdmVcbiAqIGlucHV0IGVsZW1lbnQuIFRvIGRvIHRoaXMsIHlvdSBjYW4gcHJvdmlkZSB0aGUgYG9uSW5jb21pbmdVcGRhdGVgIGhvb2suXG4gKlxuICogYGBgdHMgezZ9IGZpbGVOYW1lPVwiY3VzdG9tLWNvbnRyb2wuY29tcG9uZW50LnRzXCJcbiAqIEBDb21wb25lbnQoe30pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tQ29udHJvbENvbXBvbmVudCBleHRlbmRzIERJQ29udHJvbDxzdHJpbmc+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoe1xuICogICAgICAgb25JbmNvbWluZ1VwZGF0ZTogKHZhbHVlOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gKiAgICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gKiAgICAgICB9LFxuICogICAgIH0pO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRElDb250cm9sPFRNb2RlbCwgVENoaWxkTW9kZWwgPSBUTW9kZWw+XG4gIGV4dGVuZHMgRElDb250cm9sVmFsdWVBY2Nlc3NvcjxUTW9kZWw+XG4gIGltcGxlbWVudHMgT25Jbml0XG57XG4gIC8qKlxuICAgKiBMaXN0IG9mIGNoaWxkcmVuIGNvbnRyb2xzLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIGNoaWxkcmVuOiBTZXQ8RElDb250cm9sPFRDaGlsZE1vZGVsPj4gPSBuZXcgU2V0PERJQ29udHJvbDxUQ2hpbGRNb2RlbD4+KCk7XG4gIC8qKlxuICAgKiBDb250cm9sIGZyb20gd2hpY2ggd2UgaGF2ZSB0byB1cGRhdGUgb3VyIG1vZGVsLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZUZyb206IERJQ29udHJvbDxUQ2hpbGRNb2RlbD4gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogUmVxdWVzdCBob3N0IGZvciB1cGRhdGUgdGhlIGN1cnJlbnQgY29udHJvbC5cbiAgICogSG9zdCB3aWxsIHVwZGF0ZSB0aGUgY3VycmVudCBjb250cm9sIGJhc2VkIG9uIGl0cyBjdXJyZW50IHN0YXRlIGFuZCBob3N0IGNvbnRyb2wgbG9naWMuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVxdWVzdEZvclVwZGF0ZTogKCkgPT4gdm9pZCA9IEVNUFRZX0ZVTkNUSU9OO1xuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgdXNlZCB0byBtYWtlIGNvbnRyb2wgdG91Y2hlZC5cbiAgICovXG4gIHByb3RlY3RlZCBvdmVycmlkZSB0b3VjaDogKCkgPT4gdm9pZCA9ICgpID0+IHRoaXMuY29uZmlnPy5ob3N0Py50b3VjaCgpO1xuXG4gIHByaXZhdGUgb25Db250cm9sQ2hhbmdlRm46ICh2YWx1ZTogVE1vZGVsIHwgbnVsbCkgPT4gdm9pZCA9IEVNUFRZX0ZVTkNUSU9OO1xuICBwcml2YXRlIGRlc3Ryb3lSZWY6IERlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBjb25maWc/OiBESUNvbnRyb2xDb25maWc8VE1vZGVsLCBUQ2hpbGRNb2RlbD4pIHtcbiAgICBzdXBlcihjb25maWc/Lm9uSW5jb21pbmdVcGRhdGUpO1xuXG4gICAgdGhpcy5kZXN0cm95UmVmLm9uRGVzdHJveSgoKSA9PiB0aGlzLmNvbmZpZz8uaG9zdD8udW5yZWdpc3RlckNvbnRyb2wodGhpcykpO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgLypcbiAgICAgKiBXZSBoYXZlIHRvIHJlZ2lzdGVyIGNvbnRyb2wgd2l0aCBQcm9taXNlLnJlc29sdmUgYmVjYXVzZSBOZ01vZGVsIHVzZXMgaXQgdG9vIHRvIHNldCBmaXJzdFxuICAgICAqIHZhbHVlIChodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvN2RmOTEyNzA4OGJkYTNjOWQyOTkzN2EwNDI4N2I4N2RjMjA0NWVhNy9wYWNrYWdlcy9mb3Jtcy9zcmMvZGlyZWN0aXZlcy9uZ19tb2RlbC50cyNMMzE0KVxuICAgICAqL1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy5jb25maWc/Lmhvc3Q/LnJlZ2lzdGVyQ29udHJvbCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHByb3ZpZGVkIGNvbnRyb2wgYXMgYSBjaGlsZCBvZiB0aGUgY3VycmVudCBjb250cm9sLlxuICAgKlxuICAgKiBAcGFyYW0gY29udHJvbCAtIGNvbnRyb2wgdGhhdCB3aWxsIGJlIHJlZ2lzdGVyZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJDb250cm9sKGNvbnRyb2w6IERJQ29udHJvbDxUQ2hpbGRNb2RlbD4pOiB2b2lkIHtcbiAgICB0aGlzLmNoaWxkcmVuLmFkZChjb250cm9sKTtcblxuICAgIC8qXG4gICAgICogV2UgaGF2ZSB0byB1cGRhdGUgY29udHJvbCBiZWNhdXNlIGl0cyBjYW4gYmUgY3JlYXRlZCBkeW5hbWljYWxseS5cbiAgICAgKiBXZSB1c2UgUHJvbWlzZS5yZXNvbHZlIGJlY2F1c2UgTmdNb2RlbCB1c2VzIGl0IHRvbyB0byBzZXQgZmlyc3QgdmFsdWUgKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83ZGY5MTI3MDg4YmRhM2M5ZDI5OTM3YTA0Mjg3Yjg3ZGMyMDQ1ZWE3L3BhY2thZ2VzL2Zvcm1zL3NyYy9kaXJlY3RpdmVzL25nX21vZGVsLnRzI0wzMTQpXG4gICAgICogc28gdGhlcmUncyBubyBuZWVkIHRvIHVzZSBhbmd1bGFyIGxpZmUgY3ljbGUgaG9va3NcbiAgICAgKi9cbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbChjb250cm9sLCB0aGlzLm1vZGVsKCkpO1xuICAgIH0pO1xuXG4gICAgY29udHJvbC5yZWdpc3Rlck9uQ29udHJvbENoYW5nZSgodmFsdWU6IHVua25vd24gfCBudWxsKSA9PiB7XG4gICAgICB0aGlzLmNoaWxkQ29udHJvbENoYW5nZShjb250cm9sLCB2YWx1ZSBhcyBUTW9kZWwgfCBudWxsKTtcbiAgICAgIHRoaXMuY29uZmlnPy5vbkNoaWxkQ29udHJvbENoYW5nZT8uKGNvbnRyb2wsIHZhbHVlIGFzIFRNb2RlbCB8IG51bGwpO1xuICAgIH0pO1xuXG4gICAgY29udHJvbC5yZWdpc3RlclJlcXVlc3RGb3JVcGRhdGUoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDb250cm9sKGNvbnRyb2wsIHRoaXMubW9kZWwoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgcHJvdmlkZWQgY29udHJvbCBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2wuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cm9sIC0gY29udHJvbCB0aGF0IHdpbGwgYmUgdW5yZWdpc3RlcmVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVucmVnaXN0ZXJDb250cm9sKGNvbnRyb2w6IERJQ29udHJvbDxUQ2hpbGRNb2RlbD4pOiB2b2lkIHtcbiAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShjb250cm9sKTtcbiAgfVxuXG4gIG92ZXJyaWRlIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy50b3VjaCA9ICgpID0+IHtcbiAgICAgIGZuKCk7XG5cbiAgICAgIC8vIFRvdWNoIGhvc3QgY29udHJvbCB0byB1cGRhdGUgaXRzIHN0YXRlXG4gICAgICB0aGlzLmNvbmZpZz8uaG9zdD8udG91Y2goKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBwcm92aWRlZCBmdW5jdGlvbiBhcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY3VycmVudCBjb250cm9sIGNoYW5nZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBwcm92aWRlZCBieSB0aGUgaG9zdCBjb250cm9sIHRvIHVwZGF0ZSBpdHMgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25Db250cm9sQ2hhbmdlKGZuOiAodmFsdWU6IFRNb2RlbCB8IG51bGwpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29udHJvbENoYW5nZUZuID0gZm47XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHByb3ZpZGVkIGZ1bmN0aW9uIGFzIGEgY2FsbGJhY2sgdGhhdCBjYW4gYmUgY2FsbGVkIHRvIHJlcXVlc3QgYW4gdXBkYXRlIGZyb20gdGhlIGhvc3QgY29udHJvbC5cbiAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHRoZSBob3N0IGNvbnRyb2wgd2lsbCB1cGRhdGUgdGhlIG1vZGVsIG9mIHRoZSBjdXJyZW50IGNvbnRyb2wgYmFzZWQgb24gdGhlIGN1cnJlbnRcbiAgICogc3RhdGUgb2YgdGhlIGNvbnRyb2wgYW5kIGhvc3QgY29udHJvbCBsb2dpYy5cbiAgICpcbiAgICogQHBhcmFtIGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJSZXF1ZXN0Rm9yVXBkYXRlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5yZXF1ZXN0Rm9yVXBkYXRlID0gZm47XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbW9kZWwgb2YgdGhlIGN1cnJlbnQgY29udHJvbC5cbiAgICogVGhpcyBpcyB0aGUgbWFpbiBtZXRob2QgdGhhdCBzaG91bGQgYmUgdXNlZCB0byB1cGRhdGUgdGhlIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBuZXcgdmFsdWUuXG4gICAqL1xuICBvdmVycmlkZSB1cGRhdGVNb2RlbCh2YWx1ZTogVE1vZGVsIHwgbnVsbCk6IHZvaWQge1xuICAgIHN1cGVyLnVwZGF0ZU1vZGVsKHZhbHVlKTtcbiAgICB0aGlzLm9uQ29udHJvbENoYW5nZUZuKHZhbHVlKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRyb2xzKHRoaXMubW9kZWwoKSk7XG4gIH1cblxuICBvdmVycmlkZSB3cml0ZVZhbHVlKHZhbHVlOiBUTW9kZWwgfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9kZWwoKSAhPT0gdmFsdWUpIHtcbiAgICAgIHN1cGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgICAgdGhpcy51cGRhdGVDb250cm9scyh2YWx1ZSk7XG4gICAgICB0aGlzLm9uQ29udHJvbENoYW5nZUZuKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgaG9zdCB0byB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBuZXcgdmFsdWVcbiAgICogQGludGVybmFsXG4gICAqL1xuICB3cml0ZVZhbHVlRnJvbUhvc3QodmFsdWU6IFRNb2RlbCB8IG51bGwpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb2RlbCgpICE9PSB2YWx1ZSkge1xuICAgICAgc3VwZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICB0aGlzLmNoYW5nZSh2YWx1ZSk7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRyb2xzKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgY2hpbGQgY29udHJvbHMgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIG5ldyB2YWx1ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVDb250cm9scyh2YWx1ZTogVE1vZGVsIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY29udHJvbDogRElDb250cm9sPFRDaGlsZE1vZGVsPikgPT4ge1xuICAgICAgaWYgKGNvbnRyb2wgIT09IHRoaXMudXBkYXRlRnJvbSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRyb2woY29udHJvbCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlRnJvbSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBwcm92aWRlZCBjb250cm9sIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gY29udHJvbCAtIGNvbnRyb2wgdGhhdCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIG5ldyB2YWx1ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVDb250cm9sKGNvbnRyb2w6IERJQ29udHJvbDxUQ2hpbGRNb2RlbD4sIHZhbHVlOiBUTW9kZWwgfCBudWxsKTogdm9pZCB7XG4gICAgY29udHJvbC53cml0ZVZhbHVlRnJvbUhvc3QodmFsdWUgYXMgVENoaWxkTW9kZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGNhdGNoZXMgdXBkYXRlcyBmcm9tIGNoaWxkIGNvbnRyb2xzIGFuZCB1cGRhdGVzIHRoZSBjdXJyZW50IGNvbnRyb2wgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cm9sIC0gY29udHJvbCB0aGF0IHdhcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBuZXcgdmFsdWUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgY2hpbGRDb250cm9sQ2hhbmdlKGNvbnRyb2w6IERJQ29udHJvbDxUQ2hpbGRNb2RlbD4sIHZhbHVlOiBUTW9kZWwgfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9kZWwoKSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMudXBkYXRlRnJvbSA9IGNvbnRyb2w7XG4gICAgICB0aGlzLnVwZGF0ZU1vZGVsKHZhbHVlKTtcbiAgICAgIHRoaXMuaW5jb21pbmdVcGRhdGUgJiYgdGhpcy5pbmNvbWluZ1VwZGF0ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG59XG4iXX0=