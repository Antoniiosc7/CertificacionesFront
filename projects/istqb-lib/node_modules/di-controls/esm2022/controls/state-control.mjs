import { computed, Directive, effect, Input } from '@angular/core';
import { DI_DEFAULT_COMPARE } from 'di-controls/constants';
import { DIControl } from './control';
import * as i0 from "@angular/core";
/**
 * `DIStateControl` can be used to implement state controls (checkbox, radio, chip, switch, etc.).
 * It extends `DIControl` and adds `checked` signal that can be used to get checked state.
 * By default it works with `boolean` type, it adds `value` input that can be used to set custom
 * "true" value.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DIStateControl` class.
 * After that your control will be able to work with `NgModel`, `FormControl`.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *    super();
 *  }
 * }
 *  ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({host: injectHostControl({optional: true})});
 *   }
 * }
 * ```
 *
 * ## Getting checked state
 * To get checked state you need to use `checked` signal. It will return `true` if the current control is checked,
 * `false` if it is unchecked and `null` if it is in intermediate state.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DIControl<string> {
 *   constructor() {
 *     super();
 *
 *     console.log(this.checked());
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.checked());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you should use `check`, `uncheck`, `intermediate` or `toggle` methods.
 * They will update model based on the current state and configuration.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.toggle();
 *   }
 * }
 * ```
 *
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent<T = boolean> extends DIStateControl<T>  {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: string | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 *
 * ## Changing styles based on the state
 * `DIStateControl` binds `aria-checked` attribute to the host element.
 * You can use it to change styles of your child elements.
 *
 * ```ts {7,12,17} fileName="custom-control.component.ts"
 * @Component({
 *   selector: 'custom-control',
 *   template: ``,
 *   styles: [`
 *     :host {
 *       // checked
 *       &[aria-checked="true"] {
 *         color: green;
 *       }
 *
 *       // unchecked
 *       &[aria-checked="false"] {
 *         color: red;
 *       }
 *
 *       // intermediate
 *       &[aria-checked="mixed"] {
 *         color: blue;
 *       }
 *   `],
 *   changeDetection: ChangeDetectionStrategy.OnPush,
 *  })
 *  export class CustomControlComponent<T = boolean> extends DIStateControl<T>  {
 *    constructor() {
 *      super();
 *    }
 *  }
 *  ```
 *
 *  ## Using with DICollectionControl
 *  Using `DIStateControl` together with `DICollectionControl` will result in
 *  `DICollectionControl` containing a list of values from `DIStateControl` that have
 *  a checked state. If your `DIStateControl` has objects as values, you may
 *  likely need a comparison function because they can sometimes be immutable.
 *
 * To achieve this, provide your `DICollectionControl` as a `DICompareHost` and
 * inject it into your `DIStateControl` to give `DIStateControl` access to
 * the `compareFn` function.
 *
 * ```ts {3-4} fileName="checkbox-group.component.ts"
 * @Component({
 *   providers: [
 *     provideHostControl(CheckboxGroupComponent),
 *     provideCompareHost(CheckboxGroupComponent),
 *   ],
 * })
 * export class CheckboxGroupComponent<T> extends DICollectionControl<T> {
 *   constructor() {
 *     super();
 *   }
 * }
 * ```
 *
 * ```ts {5-7} fileName="checkbox.component.ts"
 * @Component()
 * export class CheckboxComponent<T> extends DIStateControl<T> {
 *   constructor() {
 *     super({
 *       host: injectHostControl({ optional: true }),
 *       compareHost: inject(DICompareHost, { optional: true }),
 *       hasIntermediate: true,
 *     });
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.toggle();
 *   }
 * }
 * ```
 */
class DIStateControl extends DIControl {
    config;
    value = true;
    checked = computed(() => {
        const compareFn = this.config?.compareHost?.compareFn ?? DI_DEFAULT_COMPARE;
        return compareFn(this.value, this.model()) ? true : this.isIntermediate ? null : false;
    });
    constructor(config) {
        super(config);
        this.config = config;
        // Setting aria attributes
        effect(() => {
            const ariaChecked = this.checked() === null ? 'mixed' : this.checked();
            this.renderer.setAttribute(this.elementRef.nativeElement, 'aria-checked', `${ariaChecked}`);
        });
    }
    ngOnChanges({ value }) {
        /*
         * We have to request host for updates, because when we use ngFor directive
         * with trackBy function, Angular doesn't re-create components, it just changes their inputs,
         * so we have to request for updates our host, to determine right checked state
         */
        if (value) {
            this.requestForUpdate();
        }
    }
    /** Sets checked state */
    check() {
        this.updateModel(this.value);
    }
    /** Sets unchecked state */
    uncheck() {
        this.updateModel(false);
    }
    /** Sets intermediate state */
    intermediate() {
        this.updateModel(null);
    }
    /** Toggles checked state */
    toggle() {
        this.updateModel(this.checked() === false ? this.value : false);
    }
    get isIntermediate() {
        return this.model() === null && !!this.config?.hasIntermediate;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIStateControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIStateControl, inputs: { value: "value" }, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
}
export { DIStateControl };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIStateControl, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: function () { return [{ type: undefined }]; }, propDecorators: { value: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtY29udHJvbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvZGktY29udHJvbHMvY29udHJvbHMvc3RhdGUtY29udHJvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFtQyxNQUFNLGVBQWUsQ0FBQztBQUVuRyxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsU0FBUyxFQUFrQixNQUFNLFdBQVcsQ0FBQzs7QUFpQnJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0xHO0FBQ0gsTUFDc0IsY0FDckIsU0FBUSxTQUEyQjtJQWNOO0lBVjdCLEtBQUssR0FBa0IsSUFBSSxDQUFDO0lBRTVCLE9BQU8sR0FBMkIsUUFBUSxDQUFDLEdBQUcsRUFBRTtRQUMvQyxNQUFNLFNBQVMsR0FDZCxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxTQUFTLElBQUksa0JBQWtCLENBQUM7UUFFM0QsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUN4RixDQUFDLENBQUMsQ0FBQztJQUVILFlBQzZCLE1BQStDO1FBRTNFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUZjLFdBQU0sR0FBTixNQUFNLENBQXlDO1FBSTNFLDBCQUEwQjtRQUMxQixNQUFNLENBQUMsR0FBRyxFQUFFO1lBQ1gsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFdkUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsY0FBYyxFQUFFLEdBQUcsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUM3RixDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxXQUFXLENBQUMsRUFBRSxLQUFLLEVBQWlCO1FBQ25DOzs7O1dBSUc7UUFDSCxJQUFJLEtBQUssRUFBRTtZQUNWLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1NBQ3hCO0lBQ0YsQ0FBQztJQUVELHlCQUF5QjtJQUN6QixLQUFLO1FBQ0osSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELDJCQUEyQjtJQUMzQixPQUFPO1FBQ04sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsOEJBQThCO0lBQzlCLFlBQVk7UUFDWCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRCw0QkFBNEI7SUFDNUIsTUFBTTtRQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVELElBQUksY0FBYztRQUNqQixPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsZUFBZSxDQUFDO0lBQ2hFLENBQUM7dUdBNURvQixjQUFjOzJGQUFkLGNBQWM7O1NBQWQsY0FBYzsyRkFBZCxjQUFjO2tCQURuQyxTQUFTO21CQUFDLEVBQUU7NkZBTVosS0FBSztzQkFESixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjb21wdXRlZCwgRGlyZWN0aXZlLCBlZmZlY3QsIElucHV0LCBPbkNoYW5nZXMsIFNpZ25hbCwgU2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RJQ29tcGFyZUhvc3R9IGZyb20gJ2RpLWNvbnRyb2xzL2NsYXNzZXMnO1xuaW1wb3J0IHtESV9ERUZBVUxUX0NPTVBBUkV9IGZyb20gJ2RpLWNvbnRyb2xzL2NvbnN0YW50cyc7XG5pbXBvcnQge0RJQ29udHJvbCwgRElDb250cm9sQ29uZmlnfSBmcm9tICcuL2NvbnRyb2wnO1xuaW1wb3J0IHtESUNvbXBhcmVGdW5jdGlvbn0gZnJvbSAnZGktY29udHJvbHMvdHlwZXMnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBgRElTdGF0ZUNvbnRyb2xgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERJU3RhdGVDb250cm9sQ29uZmlnPFRNb2RlbD4gZXh0ZW5kcyBESUNvbnRyb2xDb25maWc8VE1vZGVsLCBUTW9kZWw+IHtcblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbXBhcmUgaG9zdCB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IGNvbnRyb2wgdmFsdWUuXG5cdCAqL1xuXHRjb21wYXJlSG9zdD86IERJQ29tcGFyZUhvc3Q8VE1vZGVsIHwgbnVsbD4gfCBudWxsO1xuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgY29udHJvbCBjYW4gaGF2ZSBpbnRlcm1lZGlhdGUgc3RhdGUuXG5cdCAqL1xuXHRoYXNJbnRlcm1lZGlhdGU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIGBESVN0YXRlQ29udHJvbGAgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IHN0YXRlIGNvbnRyb2xzIChjaGVja2JveCwgcmFkaW8sIGNoaXAsIHN3aXRjaCwgZXRjLikuXG4gKiBJdCBleHRlbmRzIGBESUNvbnRyb2xgIGFuZCBhZGRzIGBjaGVja2VkYCBzaWduYWwgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgY2hlY2tlZCBzdGF0ZS5cbiAqIEJ5IGRlZmF1bHQgaXQgd29ya3Mgd2l0aCBgYm9vbGVhbmAgdHlwZSwgaXQgYWRkcyBgdmFsdWVgIGlucHV0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IGN1c3RvbVxuICogXCJ0cnVlXCIgdmFsdWUuXG4gKlxuICogIyMgQ3JlYXRpbmcgYSBjb250cm9sXG4gKiBUbyBjcmVhdGUgYSBjb250cm9sIHlvdSBuZWVkIHRvIGV4dGVuZCB5b3VyIGBAQ29tcG9uZW50YCBvciBgQERpcmVjdGl2ZWAgZnJvbSBgRElTdGF0ZUNvbnRyb2xgIGNsYXNzLlxuICogQWZ0ZXIgdGhhdCB5b3VyIGNvbnRyb2wgd2lsbCBiZSBhYmxlIHRvIHdvcmsgd2l0aCBgTmdNb2RlbGAsIGBGb3JtQ29udHJvbGAuXG4gKlxuICogYGBgdHMgZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50PFQgPSBib29sZWFuPiBleHRlbmRzIERJU3RhdGVDb250cm9sPFQ+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICBzdXBlcigpO1xuICogIH1cbiAqIH1cbiAqICBgYGBcbiAqXG4gKiAjIyBJbmplY3RpbmcgaG9zdCBjb250cm9sXG4gKiBCeSBkZWZhdWx0IHlvdXIgY29udHJvbCBkb2Vzbid0IGNvbW11bmljYXRlIHdpdGggaG9zdCBjb250cm9scy4gQnV0IHlvdSBjYW4gaW5qZWN0IGhvc3QgY29udHJvbCBhbmQgcHV0IGl0XG4gKiBpbnRvIGBzdXBlcmAgY2FsbC4gVGhpcyB3aWxsIHJlZ2lzdGVyIHlvdXIgY29udHJvbCBpbiB0aGUgaG9zdCBjb250cm9sIGFuZCBzdGFydCBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlbS5cbiAqXG4gKiA+ICoqTm90ZSoqXG4gKiA+IElmIHlvdSByZWdpc3RlciB5b3VyIGNvbnRyb2wgYXMgYSBob3N0IGZvciBhbm90aGVyIGNvbnRyb2xzLCB0aGVuIHlvdSBjYW4gaW5qZWN0IGl0XG4gKiA+IG9ubHkgd2l0aCBgc2tpcFNlbGZgIG9wdGlvbi5cbiAqXG4gKiBgYGB0cyB7NX0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50PFQgPSBib29sZWFuPiBleHRlbmRzIERJU3RhdGVDb250cm9sPFQ+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgLy8gd2UgYWRkIGBvcHRpb25hbGAgb3B0aW9uIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIHRoaXMgY29udHJvbCB3aXRob3V0IGhvc3RcbiAqICAgICBzdXBlcih7aG9zdDogaW5qZWN0SG9zdENvbnRyb2woe29wdGlvbmFsOiB0cnVlfSl9KTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgR2V0dGluZyBjaGVja2VkIHN0YXRlXG4gKiBUbyBnZXQgY2hlY2tlZCBzdGF0ZSB5b3UgbmVlZCB0byB1c2UgYGNoZWNrZWRgIHNpZ25hbC4gSXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBjdXJyZW50IGNvbnRyb2wgaXMgY2hlY2tlZCxcbiAqIGBmYWxzZWAgaWYgaXQgaXMgdW5jaGVja2VkIGFuZCBgbnVsbGAgaWYgaXQgaXMgaW4gaW50ZXJtZWRpYXRlIHN0YXRlLlxuICpcbiAqIGBgYHRzIHs2fSBmaWxlTmFtZT1cImN1c3RvbS1jb250cm9sLmNvbXBvbmVudC50c1wiXG4gKiBAQ29tcG9uZW50KHt9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBESUNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKCk7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHRoaXMuY2hlY2tlZCgpKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgR2V0dGluZyBtb2RlbFxuICogVG8gZ2V0IG1vZGVsIHlvdSBuZWVkIHRvIHVzZSBgbW9kZWxgIHByb3BlcnR5LiBJdCB3aWxsIHJldHVybiBtb2RlbCBmb3IgdGhlIGN1cnJlbnQgY29udHJvbC5cbiAqXG4gKiBgYGB0cyB7OX0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50PFQgPSBib29sZWFuPiBleHRlbmRzIERJU3RhdGVDb250cm9sPFQ+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoKTtcbiAqICAgfVxuICpcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICogICBvbkNsaWNrKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMuY2hlY2tlZCgpKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgVXBkYXRpbmcgbW9kZWxcbiAqIFRvIHVwZGF0ZSBtb2RlbCB5b3Ugc2hvdWxkIHVzZSBgY2hlY2tgLCBgdW5jaGVja2AsIGBpbnRlcm1lZGlhdGVgIG9yIGB0b2dnbGVgIG1ldGhvZHMuXG4gKiBUaGV5IHdpbGwgdXBkYXRlIG1vZGVsIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBjb25maWd1cmF0aW9uLlxuICpcbiAqIGBgYHRzIHs5fSBmaWxlTmFtZT1cImN1c3RvbS1jb250cm9sLmNvbXBvbmVudC50c1wiXG4gKiBAQ29tcG9uZW50KHt9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUNvbnRyb2xDb21wb25lbnQ8VCA9IGJvb2xlYW4+IGV4dGVuZHMgRElTdGF0ZUNvbnRyb2w8VD4ge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcigpO1xuICogICB9XG4gKlxuICogICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gKiAgIG9uQ2xpY2soKSB7XG4gKiAgICAgdGhpcy50b2dnbGUoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgQ2F0Y2hpbmcgdXBkYXRlc1xuICogU29tZXRpbWVzIHlvdSBtYXkgbmVlZCB0byBjYXRjaCB1cGRhdGVzIGZyb20gZGlmZmVyZW50IHNvdXJjZXMuIEZvciBleGFtcGxlLCB0byB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBuYXRpdmVcbiAqIGlucHV0IGVsZW1lbnQuIFRvIGRvIHRoaXMsIHlvdSBjYW4gcHJvdmlkZSB0aGUgYG9uSW5jb21pbmdVcGRhdGVgIGhvb2suXG4gKlxuICogYGBgdHMgezZ9IGZpbGVOYW1lPVwiY3VzdG9tLWNvbnRyb2wuY29tcG9uZW50LnRzXCJcbiAqIEBDb21wb25lbnQoe30pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tQ29udHJvbENvbXBvbmVudDxUID0gYm9vbGVhbj4gZXh0ZW5kcyBESVN0YXRlQ29udHJvbDxUPiAge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcih7XG4gKiAgICAgICBvbkluY29taW5nVXBkYXRlOiAodmFsdWU6IHN0cmluZyB8IG51bGwpID0+IHtcbiAqICAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAqICAgICAgIH0sXG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIENoYW5naW5nIHN0eWxlcyBiYXNlZCBvbiB0aGUgc3RhdGVcbiAqIGBESVN0YXRlQ29udHJvbGAgYmluZHMgYGFyaWEtY2hlY2tlZGAgYXR0cmlidXRlIHRvIHRoZSBob3N0IGVsZW1lbnQuXG4gKiBZb3UgY2FuIHVzZSBpdCB0byBjaGFuZ2Ugc3R5bGVzIG9mIHlvdXIgY2hpbGQgZWxlbWVudHMuXG4gKlxuICogYGBgdHMgezcsMTIsMTd9IGZpbGVOYW1lPVwiY3VzdG9tLWNvbnRyb2wuY29tcG9uZW50LnRzXCJcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2N1c3RvbS1jb250cm9sJyxcbiAqICAgdGVtcGxhdGU6IGBgLFxuICogICBzdHlsZXM6IFtgXG4gKiAgICAgOmhvc3Qge1xuICogICAgICAgLy8gY2hlY2tlZFxuICogICAgICAgJlthcmlhLWNoZWNrZWQ9XCJ0cnVlXCJdIHtcbiAqICAgICAgICAgY29sb3I6IGdyZWVuO1xuICogICAgICAgfVxuICpcbiAqICAgICAgIC8vIHVuY2hlY2tlZFxuICogICAgICAgJlthcmlhLWNoZWNrZWQ9XCJmYWxzZVwiXSB7XG4gKiAgICAgICAgIGNvbG9yOiByZWQ7XG4gKiAgICAgICB9XG4gKlxuICogICAgICAgLy8gaW50ZXJtZWRpYXRlXG4gKiAgICAgICAmW2FyaWEtY2hlY2tlZD1cIm1peGVkXCJdIHtcbiAqICAgICAgICAgY29sb3I6IGJsdWU7XG4gKiAgICAgICB9XG4gKiAgIGBdLFxuICogICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50PFQgPSBib29sZWFuPiBleHRlbmRzIERJU3RhdGVDb250cm9sPFQ+ICB7XG4gKiAgICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICAgc3VwZXIoKTtcbiAqICAgIH1cbiAqICB9XG4gKiAgYGBgXG4gKlxuICogICMjIFVzaW5nIHdpdGggRElDb2xsZWN0aW9uQ29udHJvbFxuICogIFVzaW5nIGBESVN0YXRlQ29udHJvbGAgdG9nZXRoZXIgd2l0aCBgRElDb2xsZWN0aW9uQ29udHJvbGAgd2lsbCByZXN1bHQgaW5cbiAqICBgRElDb2xsZWN0aW9uQ29udHJvbGAgY29udGFpbmluZyBhIGxpc3Qgb2YgdmFsdWVzIGZyb20gYERJU3RhdGVDb250cm9sYCB0aGF0IGhhdmVcbiAqICBhIGNoZWNrZWQgc3RhdGUuIElmIHlvdXIgYERJU3RhdGVDb250cm9sYCBoYXMgb2JqZWN0cyBhcyB2YWx1ZXMsIHlvdSBtYXlcbiAqICBsaWtlbHkgbmVlZCBhIGNvbXBhcmlzb24gZnVuY3Rpb24gYmVjYXVzZSB0aGV5IGNhbiBzb21ldGltZXMgYmUgaW1tdXRhYmxlLlxuICpcbiAqIFRvIGFjaGlldmUgdGhpcywgcHJvdmlkZSB5b3VyIGBESUNvbGxlY3Rpb25Db250cm9sYCBhcyBhIGBESUNvbXBhcmVIb3N0YCBhbmRcbiAqIGluamVjdCBpdCBpbnRvIHlvdXIgYERJU3RhdGVDb250cm9sYCB0byBnaXZlIGBESVN0YXRlQ29udHJvbGAgYWNjZXNzIHRvXG4gKiB0aGUgYGNvbXBhcmVGbmAgZnVuY3Rpb24uXG4gKlxuICogYGBgdHMgezMtNH0gZmlsZU5hbWU9XCJjaGVja2JveC1ncm91cC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7XG4gKiAgIHByb3ZpZGVyczogW1xuICogICAgIHByb3ZpZGVIb3N0Q29udHJvbChDaGVja2JveEdyb3VwQ29tcG9uZW50KSxcbiAqICAgICBwcm92aWRlQ29tcGFyZUhvc3QoQ2hlY2tib3hHcm91cENvbXBvbmVudCksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIENoZWNrYm94R3JvdXBDb21wb25lbnQ8VD4gZXh0ZW5kcyBESUNvbGxlY3Rpb25Db250cm9sPFQ+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogYGBgdHMgezUtN30gZmlsZU5hbWU9XCJjaGVja2JveC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCgpXG4gKiBleHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQ8VD4gZXh0ZW5kcyBESVN0YXRlQ29udHJvbDxUPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKHtcbiAqICAgICAgIGhvc3Q6IGluamVjdEhvc3RDb250cm9sKHsgb3B0aW9uYWw6IHRydWUgfSksXG4gKiAgICAgICBjb21wYXJlSG9zdDogaW5qZWN0KERJQ29tcGFyZUhvc3QsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gKiAgICAgICBoYXNJbnRlcm1lZGlhdGU6IHRydWUsXG4gKiAgICAgfSk7XG4gKlxuICogICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gKiAgIG9uQ2xpY2soKSB7XG4gKiAgICAgdGhpcy50b2dnbGUoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe30pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRElTdGF0ZUNvbnRyb2w8VE1vZGVsPlxuXHRleHRlbmRzIERJQ29udHJvbDxUTW9kZWwgfCBib29sZWFuPlxuXHRpbXBsZW1lbnRzIE9uQ2hhbmdlc1xue1xuXHRASW5wdXQoKVxuXHR2YWx1ZTogVE1vZGVsIHwgdHJ1ZSA9IHRydWU7XG5cblx0Y2hlY2tlZDogU2lnbmFsPGJvb2xlYW4gfCBudWxsPiA9IGNvbXB1dGVkKCgpID0+IHtcblx0XHRjb25zdCBjb21wYXJlRm46IERJQ29tcGFyZUZ1bmN0aW9uPFRNb2RlbCB8IGJvb2xlYW4+ID1cblx0XHRcdHRoaXMuY29uZmlnPy5jb21wYXJlSG9zdD8uY29tcGFyZUZuID8/IERJX0RFRkFVTFRfQ09NUEFSRTtcblxuXHRcdHJldHVybiBjb21wYXJlRm4odGhpcy52YWx1ZSwgdGhpcy5tb2RlbCgpKSA/IHRydWUgOiB0aGlzLmlzSW50ZXJtZWRpYXRlID8gbnVsbCA6IGZhbHNlO1xuXHR9KTtcblxuXHRwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG5cdFx0cHJvdGVjdGVkIG92ZXJyaWRlIHJlYWRvbmx5IGNvbmZpZz86IERJU3RhdGVDb250cm9sQ29uZmlnPFRNb2RlbCB8IGJvb2xlYW4+LFxuXHQpIHtcblx0XHRzdXBlcihjb25maWcpO1xuXG5cdFx0Ly8gU2V0dGluZyBhcmlhIGF0dHJpYnV0ZXNcblx0XHRlZmZlY3QoKCkgPT4ge1xuXHRcdFx0Y29uc3QgYXJpYUNoZWNrZWQgPSB0aGlzLmNoZWNrZWQoKSA9PT0gbnVsbCA/ICdtaXhlZCcgOiB0aGlzLmNoZWNrZWQoKTtcblxuXHRcdFx0dGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWNoZWNrZWQnLCBgJHthcmlhQ2hlY2tlZH1gKTtcblx0XHR9KTtcblx0fVxuXG5cdG5nT25DaGFuZ2VzKHsgdmFsdWUgfTogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXHRcdC8qXG5cdFx0ICogV2UgaGF2ZSB0byByZXF1ZXN0IGhvc3QgZm9yIHVwZGF0ZXMsIGJlY2F1c2Ugd2hlbiB3ZSB1c2UgbmdGb3IgZGlyZWN0aXZlXG5cdFx0ICogd2l0aCB0cmFja0J5IGZ1bmN0aW9uLCBBbmd1bGFyIGRvZXNuJ3QgcmUtY3JlYXRlIGNvbXBvbmVudHMsIGl0IGp1c3QgY2hhbmdlcyB0aGVpciBpbnB1dHMsXG5cdFx0ICogc28gd2UgaGF2ZSB0byByZXF1ZXN0IGZvciB1cGRhdGVzIG91ciBob3N0LCB0byBkZXRlcm1pbmUgcmlnaHQgY2hlY2tlZCBzdGF0ZVxuXHRcdCAqL1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0Rm9yVXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFNldHMgY2hlY2tlZCBzdGF0ZSAqL1xuXHRjaGVjaygpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZU1vZGVsKHRoaXMudmFsdWUpO1xuXHR9XG5cblx0LyoqIFNldHMgdW5jaGVja2VkIHN0YXRlICovXG5cdHVuY2hlY2soKTogdm9pZCB7XG5cdFx0dGhpcy51cGRhdGVNb2RlbChmYWxzZSk7XG5cdH1cblxuXHQvKiogU2V0cyBpbnRlcm1lZGlhdGUgc3RhdGUgKi9cblx0aW50ZXJtZWRpYXRlKCk6IHZvaWQge1xuXHRcdHRoaXMudXBkYXRlTW9kZWwobnVsbCk7XG5cdH1cblxuXHQvKiogVG9nZ2xlcyBjaGVja2VkIHN0YXRlICovXG5cdHRvZ2dsZSgpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuY2hlY2tlZCgpID09PSBmYWxzZSA/IHRoaXMudmFsdWUgOiBmYWxzZSk7XG5cdH1cblxuXHRnZXQgaXNJbnRlcm1lZGlhdGUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMubW9kZWwoKSA9PT0gbnVsbCAmJiAhIXRoaXMuY29uZmlnPy5oYXNJbnRlcm1lZGlhdGU7XG5cdH1cbn1cbiJdfQ==