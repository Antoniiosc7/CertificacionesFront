import { Directive, Input } from '@angular/core';
import { SetCompare } from 'di-controls/classes';
import { DI_DEFAULT_COMPARE } from 'di-controls/constants';
import { DIControl } from './control';
import { DIStateControl } from './state-control';
import * as i0 from "@angular/core";
/**
 * `DICollectionControl` can be used to implement array controls (checkbox group, radio group, chips, etc.).
 * It has an additional integration with `DIStateControl` that allows you to use it as a host for
 * `DIStateControl` controls. If you use `DIStateControl` as a child control, then `DICollectionControl`
 * will update its model when the child control is checked or unchecked, so `DICollectionControl` will
 * contain only checked values.
 *
 * It also works with other controls, but their model should be an array.
 *
 * > **Warning**
 * > If child control model is updated with non-array value, then `DICollectionControl` will be updated with `null`.
 *
 * ## Creating a control
 * To create a control you need to extend your `@Component` or `@Directive` from `DICollectionControl` class.
 * After that your control will be able to work with `NgModel`, `FormControl`.
 *
 * ```ts fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *    super();
 *  }
 * }
 *  ```
 *
 * ## Registering as a host
 * By default your control can work only with `NgModel` and `FormControl`. But you can register your control as a host
 * for another controls, then your control will be able to update them and accept updates from them. To do that you need to
 * use `provideHostControl` function.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideHostControl(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super();
 *   }
 * }
 * ```
 *
 * ## Injecting host control
 * By default your control doesn't communicate with host controls. But you can inject host control and put it
 * into `super` call. This will register your control in the host control and start communication between them.
 *
 * > **Note**
 * > If you register your control as a host for another controls, then you can inject it
 * > only with `skipSelf` option.
 *
 * ```ts {5} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     // we add `optional` option to make it possible to use this control without host
 *     super({host: injectHostControl({optional: true})});
 *   }
 * }
 * ```
 *
 * ## Getting model
 * To get model you need to use `model` property. It will return model for the current control.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     console.log(this.model());
 *   }
 * }
 * ```
 *
 * ## Updating model
 * To update model you need to call `updateModel` method. It will update model for the current control and all
 * children controls, as well as for the `NgModel` or `FormControl`.
 *
 * ```ts {9} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super();
 *   }
 *
 *   @HostListener('click')
 *   onClick() {
 *     this.updateModel(['new value']);
 *   }
 * }
 * ```
 * ## Catching updates
 * Sometimes you may need to catch updates from different sources. For example, to update the value of the native
 * input element. To do this, you can provide the `onIncomingUpdate` hook.
 *
 * ```ts {6} fileName="custom-control.component.ts"
 * @Component({})
 * export class CustomControlComponent extends DICollectionControl<string> {
 *   constructor() {
 *     super({
 *       onIncomingUpdate: (value: string[] | null) => {
 *         this.elementRef.nativeElement.value = value;
 *       },
 *     });
 *   }
 * }
 * ```
 *
 * ## Comparing values
 * By default `DICollectionControl` uses `===` operator to compare values. It may be not enough for some cases,
 * for example, when you want to compare immutable objects. To solve this problem you can provide `compareFn`
 * function and provide your control as a `DICompareHost`. It will be used to compare values in the array.
 *
 * > **Warning**
 * > This function will be used by `DIStateControl` to compare values, to set checked state.
 * > Don't forget to inject `DICompareHost` in your `DIStateControl` to make it work.
 *
 * ```ts {2} fileName="custom-control.component.ts"
 * @Component({
 *   providers: [provideCompareHost(CustomControlComponent)],
 * })
 * export class CustomControlComponent extends DICollectionControl<string> {
 *  constructor() {
 *    super()
 *  }
 * }
 * ```
 */
class DICollectionControl extends DIControl {
    config;
    /**
     * Function that will be used to compare values in the array.
     * Useful when you want to compare objects by some property (e.g. `id`).
     */
    compareFn = DI_DEFAULT_COMPARE;
    proxyModel = new SetCompare();
    constructor(config) {
        super(config);
        this.config = config;
    }
    updateModel(obj) {
        this.proxyModel = new SetCompare(this.compareFn, obj);
        super.updateModel(obj);
    }
    writeValue(value) {
        this.proxyModel = new SetCompare(this.compareFn, value);
        super.writeValue(value);
    }
    writeValueFromHost(obj) {
        this.proxyModel = new SetCompare(this.compareFn, obj);
        super.writeValueFromHost(obj);
    }
    childControlChange(control, value) {
        this.updateFrom = control;
        this.updateModel(this.getNewModel(control, value));
        this.incomingUpdate && this.incomingUpdate(this.model());
    }
    getNewModel(control, updates) {
        if (control instanceof DIStateControl) {
            control.checked()
                ? this.proxyModel.add(control.value)
                : this.proxyModel.delete(control.value);
        }
        else if (Array.isArray(updates)) {
            this.proxyModel = new SetCompare(this.compareFn, updates);
        }
        else {
            this.proxyModel = new SetCompare(this.compareFn);
            return null;
        }
        return this.proxyModel.toArray();
    }
    updateControl(control) {
        if (control instanceof DIStateControl) {
            control.writeValueFromHost(this.proxyModel.has(control.value) ? control.value : false);
        }
        else {
            control.writeValueFromHost(this.model());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DICollectionControl, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DICollectionControl, inputs: { compareFn: "compareFn" }, usesInheritance: true, ngImport: i0 });
}
export { DICollectionControl };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DICollectionControl, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; }, propDecorators: { compareFn: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi1jb250cm9sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy9kaS1jb250cm9scy9jb250cm9scy9jb2xsZWN0aW9uLWNvbnRyb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDL0MsT0FBTyxFQUFnQixVQUFVLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUM5RCxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV6RCxPQUFPLEVBQUMsU0FBUyxFQUFrQixNQUFNLFdBQVcsQ0FBQztBQUNyRCxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0saUJBQWlCLENBQUM7O0FBYS9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpSUc7QUFDSCxNQUNzQixtQkFDckIsU0FBUSxTQUFzQztJQVlMO0lBVHpDOzs7T0FHRztJQUVILFNBQVMsR0FBOEIsa0JBQWtCLENBQUM7SUFFbEQsVUFBVSxHQUF1QixJQUFJLFVBQVUsRUFBVSxDQUFDO0lBRWxFLFlBQXlDLE1BQTZEO1FBQ3JHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUQwQixXQUFNLEdBQU4sTUFBTSxDQUF1RDtJQUV0RyxDQUFDO0lBRVEsV0FBVyxDQUFDLEdBQW9CO1FBQ3hDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUV0RCxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFUSxVQUFVLENBQUMsS0FBc0I7UUFDekMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRXhELEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVRLGtCQUFrQixDQUFDLEdBQW9CO1FBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUV0RCxLQUFLLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVrQixrQkFBa0IsQ0FDcEMsT0FBcUMsRUFDckMsS0FBc0I7UUFFdEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUM7UUFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRU8sV0FBVyxDQUNsQixPQUFxQyxFQUNyQyxPQUFpQztRQUVqQyxJQUFJLE9BQU8sWUFBWSxjQUFjLEVBQUU7WUFDdEMsT0FBTyxDQUFDLE9BQU8sRUFBRTtnQkFDaEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7Z0JBQ3BDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDekM7YUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLFVBQVUsQ0FBUyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2xFO2FBQU07WUFDTixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksVUFBVSxDQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUV6RCxPQUFPLElBQUksQ0FBQztTQUNaO1FBRUQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFa0IsYUFBYSxDQUFDLE9BQXFDO1FBQ3JFLElBQUksT0FBTyxZQUFZLGNBQWMsRUFBRTtZQUN0QyxPQUFPLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN2RjthQUFNO1lBQ04sT0FBTyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3pDO0lBQ0YsQ0FBQzt1R0FyRW9CLG1CQUFtQjsyRkFBbkIsbUJBQW1COztTQUFuQixtQkFBbUI7MkZBQW5CLG1CQUFtQjtrQkFEeEMsU0FBUzs2RkFVVCxTQUFTO3NCQURSLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtESUNvbXBhcmVIb3N0LCBTZXRDb21wYXJlfSBmcm9tICdkaS1jb250cm9scy9jbGFzc2VzJztcbmltcG9ydCB7RElfREVGQVVMVF9DT01QQVJFfSBmcm9tICdkaS1jb250cm9scy9jb25zdGFudHMnO1xuaW1wb3J0IHtESUNvbXBhcmVGdW5jdGlvbn0gZnJvbSAnZGktY29udHJvbHMvdHlwZXMnO1xuaW1wb3J0IHtESUNvbnRyb2wsIERJQ29udHJvbENvbmZpZ30gZnJvbSAnLi9jb250cm9sJztcbmltcG9ydCB7RElTdGF0ZUNvbnRyb2x9IGZyb20gJy4vc3RhdGUtY29udHJvbCc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIGBESUNvbGxlY3Rpb25Db250cm9sYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBESUNvbGxlY3Rpb25Db250cm9sQ29uZmlnPFRNb2RlbCwgVENoaWxkTW9kZWw+IGV4dGVuZHMgRElDb250cm9sQ29uZmlnPFRNb2RlbFtdLCBUQ2hpbGRNb2RlbD4ge1xuXHQvKipcblx0ICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuXHQgKiBVc2VmdWwgd2hlbiB5b3Ugd2FudCB0byBjb21wYXJlIG9iamVjdHMgYnkgc29tZSBwcm9wZXJ0eS5cblx0ICovXG5cdGNvbXBhcmVIb3N0PzogRElDb21wYXJlSG9zdDxUTW9kZWw+IHwgbnVsbDtcbn1cblxuLyoqXG4gKiBgRElDb2xsZWN0aW9uQ29udHJvbGAgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGFycmF5IGNvbnRyb2xzIChjaGVja2JveCBncm91cCwgcmFkaW8gZ3JvdXAsIGNoaXBzLCBldGMuKS5cbiAqIEl0IGhhcyBhbiBhZGRpdGlvbmFsIGludGVncmF0aW9uIHdpdGggYERJU3RhdGVDb250cm9sYCB0aGF0IGFsbG93cyB5b3UgdG8gdXNlIGl0IGFzIGEgaG9zdCBmb3JcbiAqIGBESVN0YXRlQ29udHJvbGAgY29udHJvbHMuIElmIHlvdSB1c2UgYERJU3RhdGVDb250cm9sYCBhcyBhIGNoaWxkIGNvbnRyb2wsIHRoZW4gYERJQ29sbGVjdGlvbkNvbnRyb2xgXG4gKiB3aWxsIHVwZGF0ZSBpdHMgbW9kZWwgd2hlbiB0aGUgY2hpbGQgY29udHJvbCBpcyBjaGVja2VkIG9yIHVuY2hlY2tlZCwgc28gYERJQ29sbGVjdGlvbkNvbnRyb2xgIHdpbGxcbiAqIGNvbnRhaW4gb25seSBjaGVja2VkIHZhbHVlcy5cbiAqXG4gKiBJdCBhbHNvIHdvcmtzIHdpdGggb3RoZXIgY29udHJvbHMsIGJ1dCB0aGVpciBtb2RlbCBzaG91bGQgYmUgYW4gYXJyYXkuXG4gKlxuICogPiAqKldhcm5pbmcqKlxuICogPiBJZiBjaGlsZCBjb250cm9sIG1vZGVsIGlzIHVwZGF0ZWQgd2l0aCBub24tYXJyYXkgdmFsdWUsIHRoZW4gYERJQ29sbGVjdGlvbkNvbnRyb2xgIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBudWxsYC5cbiAqXG4gKiAjIyBDcmVhdGluZyBhIGNvbnRyb2xcbiAqIFRvIGNyZWF0ZSBhIGNvbnRyb2wgeW91IG5lZWQgdG8gZXh0ZW5kIHlvdXIgYEBDb21wb25lbnRgIG9yIGBARGlyZWN0aXZlYCBmcm9tIGBESUNvbGxlY3Rpb25Db250cm9sYCBjbGFzcy5cbiAqIEFmdGVyIHRoYXQgeW91ciBjb250cm9sIHdpbGwgYmUgYWJsZSB0byB3b3JrIHdpdGggYE5nTW9kZWxgLCBgRm9ybUNvbnRyb2xgLlxuICpcbiAqIGBgYHRzIGZpbGVOYW1lPVwiY3VzdG9tLWNvbnRyb2wuY29tcG9uZW50LnRzXCJcbiAqIEBDb21wb25lbnQoe30pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tQ29udHJvbENvbXBvbmVudCBleHRlbmRzIERJQ29sbGVjdGlvbkNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgc3VwZXIoKTtcbiAqICB9XG4gKiB9XG4gKiAgYGBgXG4gKlxuICogIyMgUmVnaXN0ZXJpbmcgYXMgYSBob3N0XG4gKiBCeSBkZWZhdWx0IHlvdXIgY29udHJvbCBjYW4gd29yayBvbmx5IHdpdGggYE5nTW9kZWxgIGFuZCBgRm9ybUNvbnRyb2xgLiBCdXQgeW91IGNhbiByZWdpc3RlciB5b3VyIGNvbnRyb2wgYXMgYSBob3N0XG4gKiBmb3IgYW5vdGhlciBjb250cm9scywgdGhlbiB5b3VyIGNvbnRyb2wgd2lsbCBiZSBhYmxlIHRvIHVwZGF0ZSB0aGVtIGFuZCBhY2NlcHQgdXBkYXRlcyBmcm9tIHRoZW0uIFRvIGRvIHRoYXQgeW91IG5lZWQgdG9cbiAqIHVzZSBgcHJvdmlkZUhvc3RDb250cm9sYCBmdW5jdGlvbi5cbiAqXG4gKiBgYGB0cyB7Mn0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7XG4gKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVIb3N0Q29udHJvbChDdXN0b21Db250cm9sQ29tcG9uZW50KV0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBESUNvbGxlY3Rpb25Db250cm9sPHN0cmluZz4ge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcigpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyBJbmplY3RpbmcgaG9zdCBjb250cm9sXG4gKiBCeSBkZWZhdWx0IHlvdXIgY29udHJvbCBkb2Vzbid0IGNvbW11bmljYXRlIHdpdGggaG9zdCBjb250cm9scy4gQnV0IHlvdSBjYW4gaW5qZWN0IGhvc3QgY29udHJvbCBhbmQgcHV0IGl0XG4gKiBpbnRvIGBzdXBlcmAgY2FsbC4gVGhpcyB3aWxsIHJlZ2lzdGVyIHlvdXIgY29udHJvbCBpbiB0aGUgaG9zdCBjb250cm9sIGFuZCBzdGFydCBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlbS5cbiAqXG4gKiA+ICoqTm90ZSoqXG4gKiA+IElmIHlvdSByZWdpc3RlciB5b3VyIGNvbnRyb2wgYXMgYSBob3N0IGZvciBhbm90aGVyIGNvbnRyb2xzLCB0aGVuIHlvdSBjYW4gaW5qZWN0IGl0XG4gKiA+IG9ubHkgd2l0aCBgc2tpcFNlbGZgIG9wdGlvbi5cbiAqXG4gKiBgYGB0cyB7NX0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50IGV4dGVuZHMgRElDb2xsZWN0aW9uQ29udHJvbDxzdHJpbmc+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgLy8gd2UgYWRkIGBvcHRpb25hbGAgb3B0aW9uIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIHRoaXMgY29udHJvbCB3aXRob3V0IGhvc3RcbiAqICAgICBzdXBlcih7aG9zdDogaW5qZWN0SG9zdENvbnRyb2woe29wdGlvbmFsOiB0cnVlfSl9KTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgR2V0dGluZyBtb2RlbFxuICogVG8gZ2V0IG1vZGVsIHlvdSBuZWVkIHRvIHVzZSBgbW9kZWxgIHByb3BlcnR5LiBJdCB3aWxsIHJldHVybiBtb2RlbCBmb3IgdGhlIGN1cnJlbnQgY29udHJvbC5cbiAqXG4gKiBgYGB0cyB7OX0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50IGV4dGVuZHMgRElDb2xsZWN0aW9uQ29udHJvbDxzdHJpbmc+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoKTtcbiAqICAgfVxuICpcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICogICBvbkNsaWNrKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMubW9kZWwoKSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIFVwZGF0aW5nIG1vZGVsXG4gKiBUbyB1cGRhdGUgbW9kZWwgeW91IG5lZWQgdG8gY2FsbCBgdXBkYXRlTW9kZWxgIG1ldGhvZC4gSXQgd2lsbCB1cGRhdGUgbW9kZWwgZm9yIHRoZSBjdXJyZW50IGNvbnRyb2wgYW5kIGFsbFxuICogY2hpbGRyZW4gY29udHJvbHMsIGFzIHdlbGwgYXMgZm9yIHRoZSBgTmdNb2RlbGAgb3IgYEZvcm1Db250cm9sYC5cbiAqXG4gKiBgYGB0cyB7OX0gZmlsZU5hbWU9XCJjdXN0b20tY29udHJvbC5jb21wb25lbnQudHNcIlxuICogQENvbXBvbmVudCh7fSlcbiAqIGV4cG9ydCBjbGFzcyBDdXN0b21Db250cm9sQ29tcG9uZW50IGV4dGVuZHMgRElDb2xsZWN0aW9uQ29udHJvbDxzdHJpbmc+IHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoKTtcbiAqICAgfVxuICpcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICogICBvbkNsaWNrKCkge1xuICogICAgIHRoaXMudXBkYXRlTW9kZWwoWyduZXcgdmFsdWUnXSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogIyMgQ2F0Y2hpbmcgdXBkYXRlc1xuICogU29tZXRpbWVzIHlvdSBtYXkgbmVlZCB0byBjYXRjaCB1cGRhdGVzIGZyb20gZGlmZmVyZW50IHNvdXJjZXMuIEZvciBleGFtcGxlLCB0byB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBuYXRpdmVcbiAqIGlucHV0IGVsZW1lbnQuIFRvIGRvIHRoaXMsIHlvdSBjYW4gcHJvdmlkZSB0aGUgYG9uSW5jb21pbmdVcGRhdGVgIGhvb2suXG4gKlxuICogYGBgdHMgezZ9IGZpbGVOYW1lPVwiY3VzdG9tLWNvbnRyb2wuY29tcG9uZW50LnRzXCJcbiAqIEBDb21wb25lbnQoe30pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tQ29udHJvbENvbXBvbmVudCBleHRlbmRzIERJQ29sbGVjdGlvbkNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKHtcbiAqICAgICAgIG9uSW5jb21pbmdVcGRhdGU6ICh2YWx1ZTogc3RyaW5nW10gfCBudWxsKSA9PiB7XG4gKiAgICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gKiAgICAgICB9LFxuICogICAgIH0pO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyBDb21wYXJpbmcgdmFsdWVzXG4gKiBCeSBkZWZhdWx0IGBESUNvbGxlY3Rpb25Db250cm9sYCB1c2VzIGA9PT1gIG9wZXJhdG9yIHRvIGNvbXBhcmUgdmFsdWVzLiBJdCBtYXkgYmUgbm90IGVub3VnaCBmb3Igc29tZSBjYXNlcyxcbiAqIGZvciBleGFtcGxlLCB3aGVuIHlvdSB3YW50IHRvIGNvbXBhcmUgaW1tdXRhYmxlIG9iamVjdHMuIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSB5b3UgY2FuIHByb3ZpZGUgYGNvbXBhcmVGbmBcbiAqIGZ1bmN0aW9uIGFuZCBwcm92aWRlIHlvdXIgY29udHJvbCBhcyBhIGBESUNvbXBhcmVIb3N0YC4gSXQgd2lsbCBiZSB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzIGluIHRoZSBhcnJheS5cbiAqXG4gKiA+ICoqV2FybmluZyoqXG4gKiA+IFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGJ5IGBESVN0YXRlQ29udHJvbGAgdG8gY29tcGFyZSB2YWx1ZXMsIHRvIHNldCBjaGVja2VkIHN0YXRlLlxuICogPiBEb24ndCBmb3JnZXQgdG8gaW5qZWN0IGBESUNvbXBhcmVIb3N0YCBpbiB5b3VyIGBESVN0YXRlQ29udHJvbGAgdG8gbWFrZSBpdCB3b3JrLlxuICpcbiAqIGBgYHRzIHsyfSBmaWxlTmFtZT1cImN1c3RvbS1jb250cm9sLmNvbXBvbmVudC50c1wiXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgcHJvdmlkZXJzOiBbcHJvdmlkZUNvbXBhcmVIb3N0KEN1c3RvbUNvbnRyb2xDb21wb25lbnQpXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tQ29udHJvbENvbXBvbmVudCBleHRlbmRzIERJQ29sbGVjdGlvbkNvbnRyb2w8c3RyaW5nPiB7XG4gKiAgY29uc3RydWN0b3IoKSB7XG4gKiAgICBzdXBlcigpXG4gKiAgfVxuICogfVxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERJQ29sbGVjdGlvbkNvbnRyb2w8VE1vZGVsPlxuXHRleHRlbmRzIERJQ29udHJvbDxUTW9kZWxbXSwgVE1vZGVsIHwgVE1vZGVsW10+XG5cdGltcGxlbWVudHMgRElDb21wYXJlSG9zdDxUTW9kZWw+XG57XG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb21wYXJlIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG5cdCAqIFVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGNvbXBhcmUgb2JqZWN0cyBieSBzb21lIHByb3BlcnR5IChlLmcuIGBpZGApLlxuXHQgKi9cblx0QElucHV0KClcblx0Y29tcGFyZUZuOiBESUNvbXBhcmVGdW5jdGlvbjxUTW9kZWw+ID0gRElfREVGQVVMVF9DT01QQVJFO1xuXG5cdHByaXZhdGUgcHJveHlNb2RlbDogU2V0Q29tcGFyZTxUTW9kZWw+ID0gbmV3IFNldENvbXBhcmU8VE1vZGVsPigpO1xuXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgb3ZlcnJpZGUgY29uZmlnPzogRElDb2xsZWN0aW9uQ29udHJvbENvbmZpZzxUTW9kZWwsIFRNb2RlbCB8IFRNb2RlbFtdPikge1xuXHRcdHN1cGVyKGNvbmZpZyk7XG5cdH1cblxuXHRvdmVycmlkZSB1cGRhdGVNb2RlbChvYmo6IFRNb2RlbFtdIHwgbnVsbCk6IHZvaWQge1xuXHRcdHRoaXMucHJveHlNb2RlbCA9IG5ldyBTZXRDb21wYXJlKHRoaXMuY29tcGFyZUZuLCBvYmopO1xuXG5cdFx0c3VwZXIudXBkYXRlTW9kZWwob2JqKTtcblx0fVxuXG5cdG92ZXJyaWRlIHdyaXRlVmFsdWUodmFsdWU6IFRNb2RlbFtdIHwgbnVsbCkge1xuXHRcdHRoaXMucHJveHlNb2RlbCA9IG5ldyBTZXRDb21wYXJlKHRoaXMuY29tcGFyZUZuLCB2YWx1ZSk7XG5cblx0XHRzdXBlci53cml0ZVZhbHVlKHZhbHVlKTtcblx0fVxuXG5cdG92ZXJyaWRlIHdyaXRlVmFsdWVGcm9tSG9zdChvYmo6IFRNb2RlbFtdIHwgbnVsbCkge1xuXHRcdHRoaXMucHJveHlNb2RlbCA9IG5ldyBTZXRDb21wYXJlKHRoaXMuY29tcGFyZUZuLCBvYmopO1xuXG5cdFx0c3VwZXIud3JpdGVWYWx1ZUZyb21Ib3N0KG9iaik7XG5cdH1cblxuXHRwcm90ZWN0ZWQgb3ZlcnJpZGUgY2hpbGRDb250cm9sQ2hhbmdlKFxuXHRcdGNvbnRyb2w6IERJQ29udHJvbDxUTW9kZWwgfCBUTW9kZWxbXT4sXG5cdFx0dmFsdWU6IFRNb2RlbFtdIHwgbnVsbCxcblx0KSB7XG5cdFx0dGhpcy51cGRhdGVGcm9tID0gY29udHJvbDtcblx0XHR0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuZ2V0TmV3TW9kZWwoY29udHJvbCwgdmFsdWUpKTtcblx0XHR0aGlzLmluY29taW5nVXBkYXRlICYmIHRoaXMuaW5jb21pbmdVcGRhdGUodGhpcy5tb2RlbCgpKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0TmV3TW9kZWwoXG5cdFx0Y29udHJvbDogRElDb250cm9sPFRNb2RlbCB8IFRNb2RlbFtdPixcblx0XHR1cGRhdGVzOiBUTW9kZWwgfCBUTW9kZWxbXSB8IG51bGwsXG5cdCk6IFRNb2RlbFtdIHwgbnVsbCB7XG5cdFx0aWYgKGNvbnRyb2wgaW5zdGFuY2VvZiBESVN0YXRlQ29udHJvbCkge1xuXHRcdFx0Y29udHJvbC5jaGVja2VkKClcblx0XHRcdFx0PyB0aGlzLnByb3h5TW9kZWwuYWRkKGNvbnRyb2wudmFsdWUpXG5cdFx0XHRcdDogdGhpcy5wcm94eU1vZGVsLmRlbGV0ZShjb250cm9sLnZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlcykpIHtcblx0XHRcdHRoaXMucHJveHlNb2RlbCA9IG5ldyBTZXRDb21wYXJlPFRNb2RlbD4odGhpcy5jb21wYXJlRm4sIHVwZGF0ZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnByb3h5TW9kZWwgPSBuZXcgU2V0Q29tcGFyZTxUTW9kZWw+KHRoaXMuY29tcGFyZUZuKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHJveHlNb2RlbC50b0FycmF5KCk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgb3ZlcnJpZGUgdXBkYXRlQ29udHJvbChjb250cm9sOiBESUNvbnRyb2w8VE1vZGVsIHwgVE1vZGVsW10+KTogdm9pZCB7XG5cdFx0aWYgKGNvbnRyb2wgaW5zdGFuY2VvZiBESVN0YXRlQ29udHJvbCkge1xuXHRcdFx0Y29udHJvbC53cml0ZVZhbHVlRnJvbUhvc3QodGhpcy5wcm94eU1vZGVsLmhhcyhjb250cm9sLnZhbHVlKSA/IGNvbnRyb2wudmFsdWUgOiBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRyb2wud3JpdGVWYWx1ZUZyb21Ib3N0KHRoaXMubW9kZWwoKSk7XG5cdFx0fVxuXHR9XG59XG4iXX0=