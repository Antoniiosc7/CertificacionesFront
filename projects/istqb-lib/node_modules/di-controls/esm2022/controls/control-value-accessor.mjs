import { ChangeDetectorRef, Directive, ElementRef, inject, Input, Renderer2, signal } from '@angular/core';
import { NgControl } from '@angular/forms';
import { EMPTY_FUNCTION } from 'di-controls/constants';
import { hasValue } from 'di-controls/helpers';
import * as i0 from "@angular/core";
/**
 * Base implementation of ControlValueAccessor
 */
class DIControlValueAccessor {
    incomingUpdate;
    model = signal(null);
    ngControl;
    elementRef = inject(ElementRef);
    changeDetectorRef;
    renderer = inject(Renderer2);
    disabledValue = signal(false);
    touch = EMPTY_FUNCTION;
    change = EMPTY_FUNCTION;
    constructor(incomingUpdate) {
        this.incomingUpdate = incomingUpdate;
        this.ngControl = inject(NgControl, { optional: true, self: true });
        this.changeDetectorRef = inject(ChangeDetectorRef);
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Returns true if the control is not empty.
     */
    get hasValue() {
        return hasValue(this.model());
    }
    /**
     * Returns true if the control is disabled.
     */
    get disabled() {
        return this.disabledValue();
    }
    set disabled(isDisabled) {
        this.setDisabledState(isDisabled);
    }
    /**
     * Method is called by the forms API.
     *
     * @param fn - callback function to register on value change
     * @internal
     */
    registerOnChange(fn) {
        this.change = fn;
    }
    /**
     * Method is called by the forms API.
     *
     * @param fn - callback function to register on touch
     * @internal
     */
    registerOnTouched(fn) {
        this.touch = fn;
    }
    /**
     * Method is called by the forms API to write to the view when programmatic changes from model to view are requested.
     *
     * @param obj - new value
     * @internal
     */
    writeValue(obj) {
        if (this.model() !== obj) {
            this.update(obj);
        }
    }
    /**
     * Updates the model. Use this method to update model from your Control
     *
     * @param value - new value
     */
    updateModel(value) {
        this.model.set(value);
        this.change(this.model());
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Method is called by the forms API to write to the view when programmatic changes from model to view are requested.
     *
     * @param isDisabled - new value
     * @internal
     */
    setDisabledState(isDisabled) {
        this.disabledValue.set(isDisabled);
        this.disabledValue()
            ? this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true')
            : this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
        this.renderer.setAttribute(this.elementRef.nativeElement, 'aria-disabled', `${this.disabledValue()}`);
    }
    update(value) {
        this.model.set(value);
        this.incomingUpdate && this.incomingUpdate(value);
        this.changeDetectorRef.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControlValueAccessor, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: DIControlValueAccessor, inputs: { disabled: "disabled" }, ngImport: i0 });
}
export { DIControlValueAccessor };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: DIControlValueAccessor, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }]; }, propDecorators: { disabled: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC12YWx1ZS1hY2Nlc3Nvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvZGktY29udHJvbHMvY29udHJvbHMvY29udHJvbC12YWx1ZS1hY2Nlc3Nvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04saUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxTQUFTLEVBQ1QsTUFBTSxFQUVOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBdUIsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0QsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3JELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQzs7QUFFN0M7O0dBRUc7QUFDSCxNQUNzQixzQkFBc0I7SUFXRjtJQVZ0QixLQUFLLEdBQXFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2QyxTQUFTLENBQW1CO0lBQzVCLFVBQVUsR0FBNEIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pELGlCQUFpQixDQUFvQjtJQUNyQyxRQUFRLEdBQWMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3hDLGFBQWEsR0FBNEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWhFLEtBQUssR0FBZSxjQUFjLENBQUM7SUFDbkMsTUFBTSxHQUE4QixjQUFjLENBQUM7SUFFN0QsWUFBeUMsY0FBMEM7UUFBMUMsbUJBQWMsR0FBZCxjQUFjLENBQTRCO1FBQ2xGLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDbkUsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRW5ELElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7U0FDcEM7SUFDRixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLFFBQVE7UUFDWCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLFFBQVE7UUFDWCxPQUFPLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsSUFBSSxRQUFRLENBQUMsVUFBbUI7UUFDL0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGdCQUFnQixDQUFDLEVBQTZCO1FBQzdDLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLEVBQWM7UUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsVUFBVSxDQUFDLEdBQWE7UUFDdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDakI7SUFDRixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFdBQVcsQ0FBQyxLQUFlO1FBQ3pCLElBQUksQ0FBQyxLQUFrQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxnQkFBZ0IsQ0FBQyxVQUFtQjtRQUNuQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVuQyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxVQUFVLEVBQUUsTUFBTSxDQUFDO1lBQy9FLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUM1RSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FDekIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQzdCLGVBQWUsRUFDZixHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUN6QixDQUFDO0lBQ0gsQ0FBQztJQUVPLE1BQU0sQ0FBQyxLQUFlO1FBQzVCLElBQUksQ0FBQyxLQUFrQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3ZDLENBQUM7dUdBekdvQixzQkFBc0I7MkZBQXRCLHNCQUFzQjs7U0FBdEIsc0JBQXNCOzJGQUF0QixzQkFBc0I7a0JBRDNDLFNBQVM7NkZBZ0NMLFFBQVE7c0JBRFgsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENoYW5nZURldGVjdG9yUmVmLFxuXHREaXJlY3RpdmUsXG5cdEVsZW1lbnRSZWYsXG5cdGluamVjdCxcblx0SW5wdXQsXG5cdFJlbmRlcmVyMiwgU2lnbmFsLFxuXHRzaWduYWwsXG5cdFdyaXRhYmxlU2lnbmFsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0VNUFRZX0ZVTkNUSU9OfSBmcm9tICdkaS1jb250cm9scy9jb25zdGFudHMnO1xuaW1wb3J0IHtoYXNWYWx1ZX0gZnJvbSAnZGktY29udHJvbHMvaGVscGVycyc7XG5cbi8qKlxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBDb250cm9sVmFsdWVBY2Nlc3NvclxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBESUNvbnRyb2xWYWx1ZUFjY2Vzc29yPFQ+IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgbW9kZWw6IFNpZ25hbDxUIHwgbnVsbD4gPSBzaWduYWwobnVsbCk7XG5cdHByb3RlY3RlZCByZWFkb25seSBuZ0NvbnRyb2w6IE5nQ29udHJvbCB8IG51bGw7XG5cdHByb3RlY3RlZCByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiA9IGluamVjdChFbGVtZW50UmVmKTtcblx0cHJvdGVjdGVkIHJlYWRvbmx5IGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZjtcblx0cHJvdGVjdGVkIHJlYWRvbmx5IHJlbmRlcmVyOiBSZW5kZXJlcjIgPSBpbmplY3QoUmVuZGVyZXIyKTtcblx0cHJvdGVjdGVkIHJlYWRvbmx5IGRpc2FibGVkVmFsdWU6IFdyaXRhYmxlU2lnbmFsPGJvb2xlYW4+ID0gc2lnbmFsKGZhbHNlKTtcblxuXHRwcm90ZWN0ZWQgdG91Y2g6ICgpID0+IHZvaWQgPSBFTVBUWV9GVU5DVElPTjtcblx0cHJvdGVjdGVkIGNoYW5nZTogKHZhbHVlOiBUIHwgbnVsbCkgPT4gdm9pZCA9IEVNUFRZX0ZVTkNUSU9OO1xuXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgaW5jb21pbmdVcGRhdGU/OiAodmFsdWU6IFQgfCBudWxsKSA9PiB2b2lkKSB7XG5cdFx0dGhpcy5uZ0NvbnRyb2wgPSBpbmplY3QoTmdDb250cm9sLCB7IG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0pO1xuXHRcdHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBpbmplY3QoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuXG5cdFx0aWYgKHRoaXMubmdDb250cm9sKSB7XG5cdFx0XHR0aGlzLm5nQ29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIGlzIG5vdCBlbXB0eS5cblx0ICovXG5cdGdldCBoYXNWYWx1ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gaGFzVmFsdWUodGhpcy5tb2RlbCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzYWJsZWRWYWx1ZSgpO1xuXHR9XG5cblx0c2V0IGRpc2FibGVkKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcblx0XHR0aGlzLnNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCk7XG5cdH1cblxuXHQvKipcblx0ICogTWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgZm9ybXMgQVBJLlxuXHQgKlxuXHQgKiBAcGFyYW0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbiB0byByZWdpc3RlciBvbiB2YWx1ZSBjaGFuZ2Vcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRyZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IFQgfCBudWxsKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0dGhpcy5jaGFuZ2UgPSBmbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBmb3JtcyBBUEkuXG5cdCAqXG5cdCAqIEBwYXJhbSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG9uIHRvdWNoXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0cmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcblx0XHR0aGlzLnRvdWNoID0gZm47XG5cdH1cblxuXHQvKipcblx0ICogTWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgZm9ybXMgQVBJIHRvIHdyaXRlIHRvIHRoZSB2aWV3IHdoZW4gcHJvZ3JhbW1hdGljIGNoYW5nZXMgZnJvbSBtb2RlbCB0byB2aWV3IGFyZSByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBvYmogLSBuZXcgdmFsdWVcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHR3cml0ZVZhbHVlKG9iajogVCB8IG51bGwpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5tb2RlbCgpICE9PSBvYmopIHtcblx0XHRcdHRoaXMudXBkYXRlKG9iaik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIG1vZGVsLiBVc2UgdGhpcyBtZXRob2QgdG8gdXBkYXRlIG1vZGVsIGZyb20geW91ciBDb250cm9sXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSAtIG5ldyB2YWx1ZVxuXHQgKi9cblx0dXBkYXRlTW9kZWwodmFsdWU6IFQgfCBudWxsKTogdm9pZCB7XG5cdFx0KHRoaXMubW9kZWwgYXMgV3JpdGFibGVTaWduYWw8VCB8IG51bGw+KS5zZXQodmFsdWUpO1xuXHRcdHRoaXMuY2hhbmdlKHRoaXMubW9kZWwoKSk7XG5cdFx0dGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBmb3JtcyBBUEkgdG8gd3JpdGUgdG8gdGhlIHZpZXcgd2hlbiBwcm9ncmFtbWF0aWMgY2hhbmdlcyBmcm9tIG1vZGVsIHRvIHZpZXcgYXJlIHJlcXVlc3RlZC5cblx0ICpcblx0ICogQHBhcmFtIGlzRGlzYWJsZWQgLSBuZXcgdmFsdWVcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcblx0XHR0aGlzLmRpc2FibGVkVmFsdWUuc2V0KGlzRGlzYWJsZWQpO1xuXG5cdFx0dGhpcy5kaXNhYmxlZFZhbHVlKClcblx0XHRcdD8gdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsICd0cnVlJylcblx0XHRcdDogdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcpO1xuXHRcdHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKFxuXHRcdFx0dGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXG5cdFx0XHQnYXJpYS1kaXNhYmxlZCcsXG5cdFx0XHRgJHt0aGlzLmRpc2FibGVkVmFsdWUoKX1gLFxuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZSh2YWx1ZTogVCB8IG51bGwpOiB2b2lkIHtcblx0XHQodGhpcy5tb2RlbCBhcyBXcml0YWJsZVNpZ25hbDxUIHwgbnVsbD4pLnNldCh2YWx1ZSk7XG5cdFx0dGhpcy5pbmNvbWluZ1VwZGF0ZSAmJiB0aGlzLmluY29taW5nVXBkYXRlKHZhbHVlKTtcblx0XHR0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuXHR9XG59XG4iXX0=