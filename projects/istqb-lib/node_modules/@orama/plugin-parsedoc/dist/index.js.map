{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { Document, insertMultiple, Orama } from '@orama/orama'\nimport glob from 'glob'\nimport { Content, Element, Parent, Properties, Root } from 'hast'\nimport { fromHtml } from 'hast-util-from-html'\nimport { fromString } from 'hast-util-from-string'\nimport { toHtml } from 'hast-util-to-html'\nimport { toString } from 'hast-util-to-string'\nimport { readFile } from 'node:fs/promises'\nimport { promisify } from 'node:util'\nimport { rehype } from 'rehype'\nimport rehypeDocument from 'rehype-document'\nimport rehypePresetMinify from 'rehype-preset-minify'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport { unified } from 'unified'\n\nexport type MergeStrategy = 'merge' | 'split' | 'both'\n\nexport const defaultHtmlSchema = {\n  type: 'string',\n  content: 'string',\n  path: 'string'\n} as const\n\nexport interface DefaultSchemaElement extends Document {\n  type: string\n  content: string\n  path: string\n  properties?: Properties\n}\n\ninterface PopulateFromGlobOptions {\n  transformFn?: TransformFn\n  mergeStrategy?: MergeStrategy\n}\n\ntype PopulateOptions = PopulateFromGlobOptions & { basePath?: string }\n\ntype FileType = 'html' | 'md'\nconst asyncGlob = promisify(glob)\n\nexport const populateFromGlob = async (\n  db: Orama,\n  pattern: string,\n  options?: PopulateFromGlobOptions\n): Promise<void> => {\n  const files = await asyncGlob(pattern)\n  await Promise.all(files.map(async filename => populateFromFile(db, filename, options)))\n}\n\nconst populateFromFile = async (db: Orama, filename: string, options?: PopulateFromGlobOptions): Promise<string[]> => {\n  const data = await readFile(filename)\n  const fileType = filename.slice(filename.lastIndexOf('.') + 1) as FileType\n  return populate(db, data, fileType, { ...options, basePath: `${filename}/` })\n}\n\nexport const populate = async (\n  db: Orama,\n  data: Buffer | string,\n  fileType: FileType,\n  options?: PopulateOptions\n): Promise<string[]> => {\n  const records: DefaultSchemaElement[] = []\n  switch (fileType) {\n    case 'md':\n      // eslint-disable-next-line no-case-declarations\n      const tree = unified().use(remarkParse).parse(data)\n      await unified()\n        .use(remarkRehype)\n        .use(rehypeDocument)\n        .use(rehypePresetMinify)\n        .use(rehypeOrama, records, options)\n        .run(tree)\n      break\n    case 'html':\n      await rehype().use(rehypePresetMinify).use(rehypeOrama, records, options).process(data)\n      break\n    /* c8 ignore start */\n    default:\n      return fileType\n    /* c8 ignore stop */\n  }\n  return insertMultiple(db, records)\n}\n\nfunction rehypeOrama(records: DefaultSchemaElement[], options?: PopulateOptions): (tree: Root) => void {\n  return (tree: Root) => {\n    tree.children.forEach((child, i) => {\n      visitChildren(child, tree, `${options?.basePath /* c8 ignore next */ ?? ''}root[${i}]`, records, options)\n    })\n  }\n}\n\nfunction visitChildren(\n  node: Content,\n  parent: Parent,\n  path: string,\n  records: DefaultSchemaElement[],\n  options?: PopulateOptions\n): void {\n  if (node.type === 'text') {\n    addRecords(\n      node.value,\n      (parent as Element).tagName,\n      path,\n      (parent as Element).properties,\n      records,\n      options?.mergeStrategy ?? 'merge'\n    )\n    return\n  }\n\n  if (!('tagName' in node)) return\n\n  const transformedNode = typeof options?.transformFn === 'function' ? applyTransform(node, options.transformFn) : node\n\n  transformedNode.children.forEach((child, i) => {\n    visitChildren(child, transformedNode, `${path}.${transformedNode.tagName}[${i}]`, records, options)\n  })\n}\n\nfunction applyTransform(node: Element, transformFn: TransformFn): Element {\n  const preparedNode = prepareNode(node)\n  const transformedNode = transformFn(preparedNode)\n  return applyChanges(node, transformedNode)\n}\n\nfunction prepareNode(node: Element): NodeContent {\n  const tag = node.tagName\n  const content = toString(node)\n  const raw = toHtml(node)\n  const properties = node.properties\n  return { tag, content, raw, properties }\n}\n\nfunction applyChanges(node: Element, transformedNode: NodeContent): Element {\n  if (toHtml(node) !== transformedNode.raw) {\n    return fromHtml(transformedNode.raw, { fragment: true }).children[0] as Element\n  }\n  node.tagName = transformedNode.tag\n  if (toString(node) !== transformedNode.content) {\n    return fromString(node, transformedNode.content)\n  }\n  return node\n}\n\nfunction addRecords(\n  content: string,\n  type: string,\n  path: string,\n  properties: Properties | undefined,\n  records: DefaultSchemaElement[],\n  mergeStrategy: MergeStrategy\n): void {\n  const parentPath = path.substring(0, path.lastIndexOf('.'))\n  const newRecord = { type, content, path: parentPath, properties }\n  switch (mergeStrategy) {\n    case 'merge':\n      if (!isRecordMergeable(parentPath, type, records)) {\n        records.push(newRecord)\n        return\n      }\n      addContentToLastRecord(records, content, properties)\n      return\n    case 'split':\n      records.push(newRecord)\n      return\n    case 'both':\n      if (!isRecordMergeable(parentPath, type, records)) {\n        records.push(newRecord, { ...newRecord })\n        return\n      }\n      records.splice(records.length - 1, 0, newRecord)\n      addContentToLastRecord(records, content, properties)\n  }\n}\n\nfunction isRecordMergeable(path: string, tag: string, records: DefaultSchemaElement[]): boolean {\n  if (!records.length) return false\n  const lastRecord = records[records.length - 1]\n  const parentPath = pathWithoutLastIndex(path)\n  const lastPath = pathWithoutLastIndex(lastRecord.path)\n  return parentPath === lastPath && tag === lastRecord.type\n}\n\nfunction pathWithoutLastIndex(path: string): string {\n  const lastBracket = path.lastIndexOf('[')\n  return path.slice(0, lastBracket)\n}\n\nfunction addContentToLastRecord(\n  records: Array<DefaultSchemaElement & { properties?: Properties }>,\n  content: string,\n  properties?: Properties\n): void {\n  const lastRecord = records[records.length - 1]\n  lastRecord.content += ` ${content}`\n  lastRecord.properties = { ...properties, ...lastRecord.properties }\n}\n\nexport interface NodeContent {\n  tag: string\n  raw: string\n  content: string\n  properties?: Properties\n}\n\nexport type TransformFn = (node: NodeContent) => NodeContent\n"],"names":["insertMultiple","glob","fromHtml","fromString","toHtml","toString","readFile","promisify","rehype","rehypeDocument","rehypePresetMinify","remarkParse","remarkRehype","unified","defaultHtmlSchema","type","content","path","asyncGlob","populateFromGlob","db","pattern","options","files","Promise","all","map","filename","populateFromFile","data","fileType","slice","lastIndexOf","populate","basePath","records","tree","use","parse","rehypeOrama","run","process","children","forEach","child","i","visitChildren","node","parent","addRecords","value","tagName","properties","mergeStrategy","transformedNode","transformFn","applyTransform","preparedNode","prepareNode","applyChanges","tag","raw","fragment","parentPath","substring","newRecord","isRecordMergeable","push","addContentToLastRecord","splice","length","lastRecord","pathWithoutLastIndex","lastPath","lastBracket"],"mappings":"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"}