import { __decorate, __metadata } from 'tslib';
import { ListKeyManager } from '@angular/cdk/a11y';
import * as i0 from '@angular/core';
import { ElementRef, NgZone, Component, ChangeDetectionStrategy, Inject, Optional } from '@angular/core';
import { asArray } from '@ng-doc/core/helpers/as-array';
import * as i1 from '@ng-doc/ui-kit/classes/list-host';
import { NgDocListHost } from '@ng-doc/ui-kit/classes/list-host';
import { toElement } from '@ng-doc/ui-kit/helpers';
import { untilDestroyed, UntilDestroy } from '@ngneat/until-destroy';
import { merge, fromEvent, NEVER } from 'rxjs';
import { takeUntil, delayWhen, repeat, filter } from 'rxjs/operators';

let NgDocListComponent = class NgDocListComponent {
    constructor(elementRef, ngZone, listHost) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.listHost = listHost;
        this.keyManager = null;
        this.items = new Set();
        const origin = this.listHost?.listHostOrigin
            ? toElement(this.listHost?.listHostOrigin)
            : null;
        const list = toElement(this.elementRef);
        merge(fromEvent(list, 'keydown'), origin
            ? fromEvent(origin, 'keydown').pipe(takeUntil(fromEvent(list, 'keydown')), delayWhen(() => this.ngZone.onStable), repeat())
            : NEVER)
            .pipe(filter((event) => !event.defaultPrevented), untilDestroyed(this))
            .subscribe((event) => {
            const typedEvent = event;
            switch (typedEvent.key) {
                case 'Enter':
                    this.keyManager?.activeItem?.selectByUser();
                    typedEvent.preventDefault();
                    break;
            }
            this.keyManager?.activeItem?.setInactiveStyles();
            this.keyManager?.onKeydown(typedEvent);
            this.keyManager?.activeItem?.setActiveStyles();
            if (this.keyManager?.activeItem)
                toElement(this.keyManager?.activeItem.elementRef).scrollIntoView({ block: 'nearest' });
        });
    }
    registerItem(item) {
        this.items.add(item);
        this.keyManager?.activeItem?.setInactiveStyles();
        this.keyManager = new ListKeyManager(asArray(this.items)).withVerticalOrientation(true);
    }
    unregisterItem(item) {
        this.items.delete(item);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocListComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: NgDocListHost, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.0", type: NgDocListComponent, isStandalone: true, selector: "ng-doc-list", ngImport: i0, template: "<ng-content></ng-content>\n", styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
};
NgDocListComponent = __decorate([
    UntilDestroy(),
    __metadata("design:paramtypes", [ElementRef,
        NgZone,
        NgDocListHost])
], NgDocListComponent);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ng-doc-list', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, template: "<ng-content></ng-content>\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.NgDocListHost, decorators: [{
                    type: Inject,
                    args: [NgDocListHost]
                }, {
                    type: Optional
                }] }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgDocListComponent };
//# sourceMappingURL=ng-doc-ui-kit-components-list.mjs.map
