import { __decorate, __metadata } from "tslib";
import { ListKeyManager } from '@angular/cdk/a11y';
import { ChangeDetectionStrategy, Component, ElementRef, Inject, NgZone, Optional, } from '@angular/core';
import { asArray } from '@ng-doc/core/helpers/as-array';
import { NgDocListHost } from '@ng-doc/ui-kit/classes/list-host';
import { toElement } from '@ng-doc/ui-kit/helpers';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { fromEvent, merge, NEVER } from 'rxjs';
import { delayWhen, filter, repeat, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@ng-doc/ui-kit/classes/list-host";
let NgDocListComponent = class NgDocListComponent {
    constructor(elementRef, ngZone, listHost) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.listHost = listHost;
        this.keyManager = null;
        this.items = new Set();
        const origin = this.listHost?.listHostOrigin
            ? toElement(this.listHost?.listHostOrigin)
            : null;
        const list = toElement(this.elementRef);
        merge(fromEvent(list, 'keydown'), origin
            ? fromEvent(origin, 'keydown').pipe(takeUntil(fromEvent(list, 'keydown')), delayWhen(() => this.ngZone.onStable), repeat())
            : NEVER)
            .pipe(filter((event) => !event.defaultPrevented), untilDestroyed(this))
            .subscribe((event) => {
            const typedEvent = event;
            switch (typedEvent.key) {
                case 'Enter':
                    this.keyManager?.activeItem?.selectByUser();
                    typedEvent.preventDefault();
                    break;
            }
            this.keyManager?.activeItem?.setInactiveStyles();
            this.keyManager?.onKeydown(typedEvent);
            this.keyManager?.activeItem?.setActiveStyles();
            if (this.keyManager?.activeItem)
                toElement(this.keyManager?.activeItem.elementRef).scrollIntoView({ block: 'nearest' });
        });
    }
    registerItem(item) {
        this.items.add(item);
        this.keyManager?.activeItem?.setInactiveStyles();
        this.keyManager = new ListKeyManager(asArray(this.items)).withVerticalOrientation(true);
    }
    unregisterItem(item) {
        this.items.delete(item);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocListComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: NgDocListHost, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.0", type: NgDocListComponent, isStandalone: true, selector: "ng-doc-list", ngImport: i0, template: "<ng-content></ng-content>\n", styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
};
NgDocListComponent = __decorate([
    UntilDestroy(),
    __metadata("design:paramtypes", [ElementRef,
        NgZone,
        NgDocListHost])
], NgDocListComponent);
export { NgDocListComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ng-doc-list', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, template: "<ng-content></ng-content>\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.NgDocListHost, decorators: [{
                    type: Inject,
                    args: [NgDocListHost]
                }, {
                    type: Optional
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL3VpLWtpdC9jb21wb25lbnRzL2xpc3QvbGlzdC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL3VpLWtpdC9jb21wb25lbnRzL2xpc3QvbGlzdC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFDTix1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sTUFBTSxFQUNOLFFBQVEsR0FDUixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDeEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRWpFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQVUvRCxJQUFNLGtCQUFrQixHQUF4QixNQUFNLGtCQUFrQjtJQUk5QixZQUNTLFVBQW1DLEVBQ25DLE1BQWMsRUFDcUIsUUFBd0I7UUFGM0QsZUFBVSxHQUFWLFVBQVUsQ0FBeUI7UUFDbkMsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNxQixhQUFRLEdBQVIsUUFBUSxDQUFnQjtRQU41RCxlQUFVLEdBQXlDLElBQUksQ0FBQztRQUMvQyxVQUFLLEdBQXVCLElBQUksR0FBRyxFQUFpQixDQUFDO1FBT3JFLE1BQU0sTUFBTSxHQUF1QixJQUFJLENBQUMsUUFBUSxFQUFFLGNBQWM7WUFDL0QsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQztZQUMxQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ1IsTUFBTSxJQUFJLEdBQWdCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFckQsS0FBSyxDQUNKLFNBQVMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLEVBQzFCLE1BQU07WUFDTCxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQ2pDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQ3JDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUNyQyxNQUFNLEVBQUUsQ0FDUDtZQUNILENBQUMsQ0FBQyxLQUFLLENBQ1I7YUFDQyxJQUFJLENBQ0osTUFBTSxDQUFDLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUNqRCxjQUFjLENBQUMsSUFBSSxDQUFDLENBQ3BCO2FBQ0EsU0FBUyxDQUFDLENBQUMsS0FBWSxFQUFFLEVBQUU7WUFDM0IsTUFBTSxVQUFVLEdBQWtCLEtBQXNCLENBQUM7WUFFekQsUUFBUSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ3hCLEtBQUssT0FBTztvQkFDWCxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsQ0FBQztvQkFFNUMsVUFBVSxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUM1QixNQUFNO1lBQ1IsQ0FBQztZQUVELElBQUksQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLENBQUM7WUFDakQsSUFBSSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLENBQUM7WUFFL0MsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVU7Z0JBQzlCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxjQUFjLENBQUMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQztRQUN6RixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxZQUFZLENBQUMsSUFBbUI7UUFDL0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckIsSUFBSSxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQztRQUNqRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBRUQsY0FBYyxDQUFDLElBQW1CO1FBQ2pDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLENBQUM7OEdBekRXLGtCQUFrQixrRUFPckIsYUFBYTtrR0FQVixrQkFBa0IsdUVDekIvQiw2QkFDQTs7QUR3QmEsa0JBQWtCO0lBRDlCLFlBQVksRUFBRTtxQ0FNTyxVQUFVO1FBQ2QsTUFBTTtRQUNnQyxhQUFhO0dBUHhELGtCQUFrQixDQTBEOUI7OzJGQTFEWSxrQkFBa0I7a0JBUjlCLFNBQVM7K0JBQ0MsYUFBYSxtQkFHTix1QkFBdUIsQ0FBQyxNQUFNLGNBQ25DLElBQUk7OzBCQVVkLE1BQU07MkJBQUMsYUFBYTs7MEJBQUcsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpc3RLZXlNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHtcblx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG5cdENvbXBvbmVudCxcblx0RWxlbWVudFJlZixcblx0SW5qZWN0LFxuXHROZ1pvbmUsXG5cdE9wdGlvbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGFzQXJyYXkgfSBmcm9tICdAbmctZG9jL2NvcmUvaGVscGVycy9hcy1hcnJheSc7XG5pbXBvcnQgeyBOZ0RvY0xpc3RIb3N0IH0gZnJvbSAnQG5nLWRvYy91aS1raXQvY2xhc3Nlcy9saXN0LWhvc3QnO1xuaW1wb3J0IHsgTmdEb2NMaXN0SXRlbSB9IGZyb20gJ0BuZy1kb2MvdWkta2l0L2NsYXNzZXMvbGlzdC1pdGVtJztcbmltcG9ydCB7IHRvRWxlbWVudCB9IGZyb20gJ0BuZy1kb2MvdWkta2l0L2hlbHBlcnMnO1xuaW1wb3J0IHsgVW50aWxEZXN0cm95LCB1bnRpbERlc3Ryb3llZCB9IGZyb20gJ0BuZ25lYXQvdW50aWwtZGVzdHJveSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBORVZFUiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVsYXlXaGVuLCBmaWx0ZXIsIHJlcGVhdCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICduZy1kb2MtbGlzdCcsXG5cdHRlbXBsYXRlVXJsOiAnLi9saXN0LmNvbXBvbmVudC5odG1sJyxcblx0c3R5bGVVcmxzOiBbJy4vbGlzdC5jb21wb25lbnQuc2NzcyddLFxuXHRjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcblx0c3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5AVW50aWxEZXN0cm95KClcbmV4cG9ydCBjbGFzcyBOZ0RvY0xpc3RDb21wb25lbnQge1xuXHRwcml2YXRlIGtleU1hbmFnZXI6IExpc3RLZXlNYW5hZ2VyPE5nRG9jTGlzdEl0ZW0+IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcmVhZG9ubHkgaXRlbXM6IFNldDxOZ0RvY0xpc3RJdGVtPiA9IG5ldyBTZXQ8TmdEb2NMaXN0SXRlbT4oKTtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuXHRcdHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG5cdFx0QEluamVjdChOZ0RvY0xpc3RIb3N0KSBAT3B0aW9uYWwoKSBwcml2YXRlIGxpc3RIb3N0PzogTmdEb2NMaXN0SG9zdCxcblx0KSB7XG5cdFx0Y29uc3Qgb3JpZ2luOiBIVE1MRWxlbWVudCB8IG51bGwgPSB0aGlzLmxpc3RIb3N0Py5saXN0SG9zdE9yaWdpblxuXHRcdFx0PyB0b0VsZW1lbnQodGhpcy5saXN0SG9zdD8ubGlzdEhvc3RPcmlnaW4pXG5cdFx0XHQ6IG51bGw7XG5cdFx0Y29uc3QgbGlzdDogSFRNTEVsZW1lbnQgPSB0b0VsZW1lbnQodGhpcy5lbGVtZW50UmVmKTtcblxuXHRcdG1lcmdlKFxuXHRcdFx0ZnJvbUV2ZW50KGxpc3QsICdrZXlkb3duJyksXG5cdFx0XHRvcmlnaW5cblx0XHRcdFx0PyBmcm9tRXZlbnQob3JpZ2luLCAna2V5ZG93bicpLnBpcGUoXG5cdFx0XHRcdFx0XHR0YWtlVW50aWwoZnJvbUV2ZW50KGxpc3QsICdrZXlkb3duJykpLFxuXHRcdFx0XHRcdFx0ZGVsYXlXaGVuKCgpID0+IHRoaXMubmdab25lLm9uU3RhYmxlKSxcblx0XHRcdFx0XHRcdHJlcGVhdCgpLFxuXHRcdFx0XHQgIClcblx0XHRcdFx0OiBORVZFUixcblx0XHQpXG5cdFx0XHQucGlwZShcblx0XHRcdFx0ZmlsdGVyKChldmVudDogRXZlbnQpID0+ICFldmVudC5kZWZhdWx0UHJldmVudGVkKSxcblx0XHRcdFx0dW50aWxEZXN0cm95ZWQodGhpcyksXG5cdFx0XHQpXG5cdFx0XHQuc3Vic2NyaWJlKChldmVudDogRXZlbnQpID0+IHtcblx0XHRcdFx0Y29uc3QgdHlwZWRFdmVudDogS2V5Ym9hcmRFdmVudCA9IGV2ZW50IGFzIEtleWJvYXJkRXZlbnQ7XG5cblx0XHRcdFx0c3dpdGNoICh0eXBlZEV2ZW50LmtleSkge1xuXHRcdFx0XHRcdGNhc2UgJ0VudGVyJzpcblx0XHRcdFx0XHRcdHRoaXMua2V5TWFuYWdlcj8uYWN0aXZlSXRlbT8uc2VsZWN0QnlVc2VyKCk7XG5cblx0XHRcdFx0XHRcdHR5cGVkRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5rZXlNYW5hZ2VyPy5hY3RpdmVJdGVtPy5zZXRJbmFjdGl2ZVN0eWxlcygpO1xuXHRcdFx0XHR0aGlzLmtleU1hbmFnZXI/Lm9uS2V5ZG93bih0eXBlZEV2ZW50KTtcblx0XHRcdFx0dGhpcy5rZXlNYW5hZ2VyPy5hY3RpdmVJdGVtPy5zZXRBY3RpdmVTdHlsZXMoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5rZXlNYW5hZ2VyPy5hY3RpdmVJdGVtKVxuXHRcdFx0XHRcdHRvRWxlbWVudCh0aGlzLmtleU1hbmFnZXI/LmFjdGl2ZUl0ZW0uZWxlbWVudFJlZikuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ25lYXJlc3QnIH0pO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZWdpc3Rlckl0ZW0oaXRlbTogTmdEb2NMaXN0SXRlbSk6IHZvaWQge1xuXHRcdHRoaXMuaXRlbXMuYWRkKGl0ZW0pO1xuXG5cdFx0dGhpcy5rZXlNYW5hZ2VyPy5hY3RpdmVJdGVtPy5zZXRJbmFjdGl2ZVN0eWxlcygpO1xuXHRcdHRoaXMua2V5TWFuYWdlciA9IG5ldyBMaXN0S2V5TWFuYWdlcihhc0FycmF5KHRoaXMuaXRlbXMpKS53aXRoVmVydGljYWxPcmllbnRhdGlvbih0cnVlKTtcblx0fVxuXG5cdHVucmVnaXN0ZXJJdGVtKGl0ZW06IE5nRG9jTGlzdEl0ZW0pOiB2b2lkIHtcblx0XHR0aGlzLml0ZW1zLmRlbGV0ZShpdGVtKTtcblx0fVxufVxuIiwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuIl19