import { Directive, ElementRef, Input, Renderer2, } from '@angular/core';
import * as i0 from "@angular/core";
/** Directive rotates host with transition */
export class NgDocRotatorDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        /** Rotator state */
        this.rotated = false;
        /** Start position angle */
        this.from = 0;
        /** End position anle */
        this.to = 90;
    }
    ngOnChanges({ rotated, to }) {
        if (rotated) {
            this.rotate(this.rotated ? this.to : this.from, true);
        }
    }
    ngOnInit() {
        this.rotate(this.rotated ? this.to : this.from);
    }
    rotate(degree, animated) {
        if (animated) {
            this.renderer.setStyle(this.elementRef.nativeElement, `transition`, `var(--ng-doc-transition)`);
        }
        this.renderer.setStyle(this.elementRef.nativeElement, `transform`, `rotateZ(${degree}deg`);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocRotatorDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.0", type: NgDocRotatorDirective, isStandalone: true, selector: "[ngDocRotator]", inputs: { rotated: ["ngDocRotator", "rotated"], from: "from", to: "to" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocRotatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngDocRotator]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }], propDecorators: { rotated: [{
                type: Input,
                args: ['ngDocRotator']
            }], from: [{
                type: Input
            }], to: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm90YXRvci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL3VpLWtpdC9kaXJlY3RpdmVzL3JvdGF0b3Ivcm90YXRvci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxVQUFVLEVBQ1YsS0FBSyxFQUdMLFNBQVMsR0FFVCxNQUFNLGVBQWUsQ0FBQzs7QUFFdkIsNkNBQTZDO0FBSzdDLE1BQU0sT0FBTyxxQkFBcUI7SUFhakMsWUFDa0IsVUFBbUMsRUFDbkMsUUFBbUI7UUFEbkIsZUFBVSxHQUFWLFVBQVUsQ0FBeUI7UUFDbkMsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQWRyQyxvQkFBb0I7UUFFcEIsWUFBTyxHQUFZLEtBQUssQ0FBQztRQUV6QiwyQkFBMkI7UUFFM0IsU0FBSSxHQUFXLENBQUMsQ0FBQztRQUVqQix3QkFBd0I7UUFFeEIsT0FBRSxHQUFXLEVBQUUsQ0FBQztJQUtiLENBQUM7SUFFSixXQUFXLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFpQjtRQUN6QyxJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3ZELENBQUM7SUFDRixDQUFDO0lBRUQsUUFBUTtRQUNQLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTyxNQUFNLENBQUMsTUFBYyxFQUFFLFFBQWtCO1FBQ2hELElBQUksUUFBUSxFQUFFLENBQUM7WUFDZCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQzdCLFlBQVksRUFDWiwwQkFBMEIsQ0FDMUIsQ0FBQztRQUNILENBQUM7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsV0FBVyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQzVGLENBQUM7OEdBckNXLHFCQUFxQjtrR0FBckIscUJBQXFCOzsyRkFBckIscUJBQXFCO2tCQUpqQyxTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxnQkFBZ0I7b0JBQzFCLFVBQVUsRUFBRSxJQUFJO2lCQUNoQjt1R0FJQSxPQUFPO3NCQUROLEtBQUs7dUJBQUMsY0FBYztnQkFLckIsSUFBSTtzQkFESCxLQUFLO2dCQUtOLEVBQUU7c0JBREQsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdERpcmVjdGl2ZSxcblx0RWxlbWVudFJlZixcblx0SW5wdXQsXG5cdE9uQ2hhbmdlcyxcblx0T25Jbml0LFxuXHRSZW5kZXJlcjIsXG5cdFNpbXBsZUNoYW5nZXMsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKiogRGlyZWN0aXZlIHJvdGF0ZXMgaG9zdCB3aXRoIHRyYW5zaXRpb24gKi9cbkBEaXJlY3RpdmUoe1xuXHRzZWxlY3RvcjogJ1tuZ0RvY1JvdGF0b3JdJyxcblx0c3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgTmdEb2NSb3RhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQge1xuXHQvKiogUm90YXRvciBzdGF0ZSAqL1xuXHRASW5wdXQoJ25nRG9jUm90YXRvcicpXG5cdHJvdGF0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXHQvKiogU3RhcnQgcG9zaXRpb24gYW5nbGUgKi9cblx0QElucHV0KClcblx0ZnJvbTogbnVtYmVyID0gMDtcblxuXHQvKiogRW5kIHBvc2l0aW9uIGFubGUgKi9cblx0QElucHV0KClcblx0dG86IG51bWJlciA9IDkwO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG5cdFx0cHJpdmF0ZSByZWFkb25seSByZW5kZXJlcjogUmVuZGVyZXIyLFxuXHQpIHt9XG5cblx0bmdPbkNoYW5nZXMoeyByb3RhdGVkLCB0byB9OiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG5cdFx0aWYgKHJvdGF0ZWQpIHtcblx0XHRcdHRoaXMucm90YXRlKHRoaXMucm90YXRlZCA/IHRoaXMudG8gOiB0aGlzLmZyb20sIHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdG5nT25Jbml0KCk6IHZvaWQge1xuXHRcdHRoaXMucm90YXRlKHRoaXMucm90YXRlZCA/IHRoaXMudG8gOiB0aGlzLmZyb20pO1xuXHR9XG5cblx0cHJpdmF0ZSByb3RhdGUoZGVncmVlOiBudW1iZXIsIGFuaW1hdGVkPzogYm9vbGVhbik6IHZvaWQge1xuXHRcdGlmIChhbmltYXRlZCkge1xuXHRcdFx0dGhpcy5yZW5kZXJlci5zZXRTdHlsZShcblx0XHRcdFx0dGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXG5cdFx0XHRcdGB0cmFuc2l0aW9uYCxcblx0XHRcdFx0YHZhcigtLW5nLWRvYy10cmFuc2l0aW9uKWAsXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBgdHJhbnNmb3JtYCwgYHJvdGF0ZVooJHtkZWdyZWV9ZGVnYCk7XG5cdH1cbn1cbiJdfQ==