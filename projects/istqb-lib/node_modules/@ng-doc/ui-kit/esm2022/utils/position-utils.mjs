export class NgDocPositionUtils {
    /**
     * Getting the position of the element relative to the viewPort, this function is faster than BoundingClientRect,
     * it also takes into account the change in the position of the element through transform
     * @param element
     */
    static getElementPosition(element) {
        let xPos = 0;
        let yPos = 0;
        while (element) {
            if (element === document.body) {
                const documentElement = document.documentElement;
                xPos +=
                    documentElement.offsetLeft - documentElement.scrollLeft + documentElement.clientLeft;
                yPos += documentElement.offsetTop - documentElement.scrollTop + documentElement.clientTop;
                element = null;
            }
            else {
                const elementMatrix = new DOMMatrix(element.style.transform);
                xPos += element.offsetLeft - element.scrollLeft + element.clientLeft + elementMatrix.m41;
                yPos += element.offsetTop - element.scrollTop + element.clientTop + elementMatrix.m42;
                element = NgDocPositionUtils.getOffsetParent(element);
            }
        }
        return { x: xPos, y: yPos };
    }
    /**
     * An implementation of the element.offsetParent function, this implementation closes a bug in Firefox when it
     * returns an offsetParent for elements with position: fixed
     * @param element
     */
    static getOffsetParent(element) {
        const computerStyles = getComputedStyle(element);
        if (computerStyles.position === 'fixed' || computerStyles.display === 'none') {
            return null;
        }
        return element.offsetParent;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zaXRpb24tdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3VpLWtpdC91dGlscy9wb3NpdGlvbi11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxNQUFNLE9BQU8sa0JBQWtCO0lBQzlCOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsa0JBQWtCLENBQUMsT0FBMkI7UUFDcEQsSUFBSSxJQUFJLEdBQVcsQ0FBQyxDQUFDO1FBQ3JCLElBQUksSUFBSSxHQUFXLENBQUMsQ0FBQztRQUVyQixPQUFPLE9BQU8sRUFBRSxDQUFDO1lBQ2hCLElBQUksT0FBTyxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDL0IsTUFBTSxlQUFlLEdBQWdCLFFBQVEsQ0FBQyxlQUFlLENBQUM7Z0JBQzlELElBQUk7b0JBQ0gsZUFBZSxDQUFDLFVBQVUsR0FBRyxlQUFlLENBQUMsVUFBVSxHQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3RGLElBQUksSUFBSSxlQUFlLENBQUMsU0FBUyxHQUFHLGVBQWUsQ0FBQyxTQUFTLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQztnQkFDMUYsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNoQixDQUFDO2lCQUFNLENBQUM7Z0JBQ1AsTUFBTSxhQUFhLEdBQWMsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDeEUsSUFBSSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUM7Z0JBQ3pGLElBQUksSUFBSSxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDO2dCQUN0RixPQUFPLEdBQUcsa0JBQWtCLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBZ0IsQ0FBQztZQUN0RSxDQUFDO1FBQ0YsQ0FBQztRQUNELE9BQU8sRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxlQUFlLENBQUMsT0FBb0I7UUFDMUMsTUFBTSxjQUFjLEdBQXdCLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RFLElBQUksY0FBYyxDQUFDLFFBQVEsS0FBSyxPQUFPLElBQUksY0FBYyxDQUFDLE9BQU8sS0FBSyxNQUFNLEVBQUUsQ0FBQztZQUM5RSxPQUFPLElBQUksQ0FBQztRQUNiLENBQUM7UUFDRCxPQUFPLE9BQU8sQ0FBQyxZQUEyQixDQUFDO0lBQzVDLENBQUM7Q0FDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2RyYWctZHJvcCc7XG5cbmV4cG9ydCBjbGFzcyBOZ0RvY1Bvc2l0aW9uVXRpbHMge1xuXHQvKipcblx0ICogR2V0dGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdQb3J0LCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIEJvdW5kaW5nQ2xpZW50UmVjdCxcblx0ICogaXQgYWxzbyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGNoYW5nZSBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgdGhyb3VnaCB0cmFuc2Zvcm1cblx0ICogQHBhcmFtIGVsZW1lbnRcblx0ICovXG5cdHN0YXRpYyBnZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsKTogUG9pbnQge1xuXHRcdGxldCB4UG9zOiBudW1iZXIgPSAwO1xuXHRcdGxldCB5UG9zOiBudW1iZXIgPSAwO1xuXG5cdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG5cdFx0XHRcdGNvbnN0IGRvY3VtZW50RWxlbWVudDogSFRNTEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdHhQb3MgKz1cblx0XHRcdFx0XHRkb2N1bWVudEVsZW1lbnQub2Zmc2V0TGVmdCAtIGRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICsgZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQ7XG5cdFx0XHRcdHlQb3MgKz0gZG9jdW1lbnRFbGVtZW50Lm9mZnNldFRvcCAtIGRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgKyBkb2N1bWVudEVsZW1lbnQuY2xpZW50VG9wO1xuXHRcdFx0XHRlbGVtZW50ID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnRNYXRyaXg6IERPTU1hdHJpeCA9IG5ldyBET01NYXRyaXgoZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0pO1xuXHRcdFx0XHR4UG9zICs9IGVsZW1lbnQub2Zmc2V0TGVmdCAtIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdCArIGVsZW1lbnRNYXRyaXgubTQxO1xuXHRcdFx0XHR5UG9zICs9IGVsZW1lbnQub2Zmc2V0VG9wIC0gZWxlbWVudC5zY3JvbGxUb3AgKyBlbGVtZW50LmNsaWVudFRvcCArIGVsZW1lbnRNYXRyaXgubTQyO1xuXHRcdFx0XHRlbGVtZW50ID0gTmdEb2NQb3NpdGlvblV0aWxzLmdldE9mZnNldFBhcmVudChlbGVtZW50KSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHsgeDogeFBvcywgeTogeVBvcyB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBlbGVtZW50Lm9mZnNldFBhcmVudCBmdW5jdGlvbiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBjbG9zZXMgYSBidWcgaW4gRmlyZWZveCB3aGVuIGl0XG5cdCAqIHJldHVybnMgYW4gb2Zmc2V0UGFyZW50IGZvciBlbGVtZW50cyB3aXRoIHBvc2l0aW9uOiBmaXhlZFxuXHQgKiBAcGFyYW0gZWxlbWVudFxuXHQgKi9cblx0c3RhdGljIGdldE9mZnNldFBhcmVudChlbGVtZW50OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG5cdFx0Y29uc3QgY29tcHV0ZXJTdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXHRcdGlmIChjb21wdXRlclN0eWxlcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBjb21wdXRlclN0eWxlcy5kaXNwbGF5ID09PSAnbm9uZScpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQgYXMgSFRNTEVsZW1lbnQ7XG5cdH1cbn1cbiJdfQ==