var NgDocThemeService_1;
import { __decorate, __metadata } from "tslib";
import { DOCUMENT } from '@angular/common';
import { afterNextRender, Inject, Injectable } from '@angular/core';
import { NG_DOC_STORE_THEME_KEY } from '@ng-doc/app/constants';
import { NgDocStoreService } from '@ng-doc/app/services/store';
import { NG_DOC_THEME } from '@ng-doc/app/tokens';
import { isBrowser } from '@ng-doc/core';
import { WINDOW } from '@ng-web-apis/common';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { fromEvent, Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@ng-doc/app/services/store";
/**
 * Service for managing themes.
 */
let NgDocThemeService = class NgDocThemeService {
    static { NgDocThemeService_1 = this; }
    static { this.autoThemeId = 'ng-doc-auto'; }
    constructor(window, document, themes, store) {
        this.window = window;
        this.document = document;
        this.themes = themes;
        this.store = store;
        this.theme = undefined;
        this.theme$ = new Subject();
        this.autoTheme = undefined;
        afterNextRender(() => {
            fromEvent(this.window.matchMedia('(prefers-color-scheme: dark)'), 'change')
                .pipe(untilDestroyed(this))
                .subscribe(() => this.setAutoTheme());
        });
    }
    /**
     * Returns the current theme.
     */
    get currentTheme() {
        return this.theme;
    }
    /**
     * Returns whether automatic theme switching based on the user's operating system settings is enabled.
     */
    get isAutoThemeEnabled() {
        return this.autoTheme !== undefined;
    }
    /**
     * Enables automatic theme switching based on the user's operating system settings.
     * @param light - Theme for light mode.
     * @param dark - Theme for dark mode.
     */
    async enableAutoTheme(light, dark) {
        this.autoTheme = [light, dark];
        return this.setAutoTheme();
    }
    /**
     * Disables automatic theme switching based on the user's operating system settings.
     */
    async disableAutoTheme() {
        this.autoTheme = undefined;
        return this.set(this.store.get(NG_DOC_STORE_THEME_KEY) ?? undefined);
    }
    /**
     * Sets the theme by id.
     * @param id - Theme id.
     * @param save - Whether to save the theme in the store to restore it when the page is reloaded. (`true` by default)
     */
    async set(id, save = true) {
        this.removeLink();
        if (save) {
            this.autoTheme = undefined;
        }
        if (id && id !== 'ng-doc-day') {
            const theme = this.themes.find((theme) => theme.id === id);
            if (!theme) {
                console.warn(`Theme with id "${id}" is not registered. Make sure that you registered it in the root of your application.`);
                return;
            }
            this.createLinkIfNoExists();
            if (this.linkElement) {
                this.linkElement.href = theme.path;
                save && this.store.set(NG_DOC_STORE_THEME_KEY, theme.id);
                this.theme = theme;
                return new Promise((resolve, reject) => {
                    if (this.linkElement) {
                        this.linkElement.onload = () => {
                            this.theme$.next(theme);
                            resolve();
                        };
                        this.linkElement.onerror = reject;
                    }
                });
            }
        }
        save && this.store.set(NG_DOC_STORE_THEME_KEY, 'ng-doc-day');
        this.theme$.next(undefined);
        return Promise.resolve();
    }
    /**
     * Returns an observable that emits when the theme changes.
     */
    themeChanges() {
        return this.theme$.asObservable();
    }
    removeLink() {
        this.theme = undefined;
        this.linkElement?.remove();
        this.linkElement = undefined;
    }
    createLinkIfNoExists() {
        if (!this.linkElement) {
            this.linkElement = this.document.createElement('link');
            this.linkElement.setAttribute('rel', 'stylesheet');
            this.linkElement.setAttribute('type', 'text/css');
            this.document.getElementsByTagName('head')[0].appendChild(this.linkElement);
        }
    }
    async setAutoTheme() {
        if (this.autoTheme !== undefined && isBrowser) {
            const isDark = this.window.matchMedia('(prefers-color-scheme: dark)').matches;
            const [light, dark] = this.autoTheme;
            this.store.set(NG_DOC_STORE_THEME_KEY, NgDocThemeService_1.autoThemeId);
            return this.set(isDark ? dark?.id : light?.id, false);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocThemeService, deps: [{ token: WINDOW }, { token: DOCUMENT }, { token: NG_DOC_THEME }, { token: i1.NgDocStoreService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocThemeService, providedIn: 'root' }); }
};
NgDocThemeService = NgDocThemeService_1 = __decorate([
    UntilDestroy(),
    __metadata("design:paramtypes", [Window,
        Document, Array, NgDocStoreService])
], NgDocThemeService);
export { NgDocThemeService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocThemeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NG_DOC_THEME]
                }] }, { type: i1.NgDocStoreService }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhlbWUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvYXBwL3NlcnZpY2VzL3RoZW1lL3RoZW1lLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRS9ELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QyxPQUFPLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxTQUFTLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7QUFFdEQ7O0dBRUc7QUFLSSxJQUFNLGlCQUFpQixHQUF2QixNQUFNLGlCQUFpQjs7YUFDYixnQkFBVyxHQUFXLGFBQWEsQUFBeEIsQ0FBeUI7SUFPcEQsWUFFa0IsTUFBYyxFQUVkLFFBQWtCLEVBRWxCLE1BQW9CLEVBQ3BCLEtBQXdCO1FBTHhCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFFZCxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBRWxCLFdBQU0sR0FBTixNQUFNLENBQWM7UUFDcEIsVUFBSyxHQUFMLEtBQUssQ0FBbUI7UUFYbEMsVUFBSyxHQUEyQixTQUFTLENBQUM7UUFDakMsV0FBTSxHQUFvQyxJQUFJLE9BQU8sRUFBMEIsQ0FBQztRQUN6RixjQUFTLEdBQWlFLFNB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QyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBRSxtQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUV0RSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3ZELENBQUM7SUFDRixDQUFDOzhHQTdJVyxpQkFBaUIsa0JBU3BCLE1BQU0sYUFFTixRQUFRLGFBRVIsWUFBWTtrSEFiVCxpQkFBaUIsY0FIakIsTUFBTTs7QUFHTixpQkFBaUI7SUFEN0IsWUFBWSxFQUFFO3FDQVdZLE1BQU07UUFFSixRQUFRLFNBR1gsaUJBQWlCO0dBZjlCLGlCQUFpQixDQThJN0I7OzJGQTlJWSxpQkFBaUI7a0JBSjdCLFVBQVU7bUJBQUM7b0JBQ1gsVUFBVSxFQUFFLE1BQU07aUJBQ2xCOzswQkFXRSxNQUFNOzJCQUFDLE1BQU07OzBCQUViLE1BQU07MkJBQUMsUUFBUTs7MEJBRWYsTUFBTTsyQkFBQyxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgYWZ0ZXJOZXh0UmVuZGVyLCBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX0RPQ19TVE9SRV9USEVNRV9LRVkgfSBmcm9tICdAbmctZG9jL2FwcC9jb25zdGFudHMnO1xuaW1wb3J0IHsgTmdEb2NUaGVtZSB9IGZyb20gJ0BuZy1kb2MvYXBwL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTmdEb2NTdG9yZVNlcnZpY2UgfSBmcm9tICdAbmctZG9jL2FwcC9zZXJ2aWNlcy9zdG9yZSc7XG5pbXBvcnQgeyBOR19ET0NfVEhFTUUgfSBmcm9tICdAbmctZG9jL2FwcC90b2tlbnMnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQG5nLWRvYy9jb3JlJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJ0BuZy13ZWItYXBpcy9jb21tb24nO1xuaW1wb3J0IHsgVW50aWxEZXN0cm95LCB1bnRpbERlc3Ryb3llZCB9IGZyb20gJ0BuZ25lYXQvdW50aWwtZGVzdHJveSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBtYW5hZ2luZyB0aGVtZXMuXG4gKi9cbkBJbmplY3RhYmxlKHtcblx0cHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbkBVbnRpbERlc3Ryb3koKVxuZXhwb3J0IGNsYXNzIE5nRG9jVGhlbWVTZXJ2aWNlIHtcblx0c3RhdGljIHJlYWRvbmx5IGF1dG9UaGVtZUlkOiBzdHJpbmcgPSAnbmctZG9jLWF1dG8nO1xuXG5cdHByaXZhdGUgbGlua0VsZW1lbnQ/OiBIVE1MTGlua0VsZW1lbnQ7XG5cdHByaXZhdGUgdGhlbWU6IE5nRG9jVGhlbWUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cdHByaXZhdGUgcmVhZG9ubHkgdGhlbWUkOiBTdWJqZWN0PE5nRG9jVGhlbWUgfCB1bmRlZmluZWQ+ID0gbmV3IFN1YmplY3Q8TmdEb2NUaGVtZSB8IHVuZGVmaW5lZD4oKTtcblx0cHJpdmF0ZSBhdXRvVGhlbWU6IFtOZ0RvY1RoZW1lIHwgdW5kZWZpbmVkLCBOZ0RvY1RoZW1lIHwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRASW5qZWN0KFdJTkRPVylcblx0XHRwcml2YXRlIHJlYWRvbmx5IHdpbmRvdzogV2luZG93LFxuXHRcdEBJbmplY3QoRE9DVU1FTlQpXG5cdFx0cHJpdmF0ZSByZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXG5cdFx0QEluamVjdChOR19ET0NfVEhFTUUpXG5cdFx0cHJpdmF0ZSByZWFkb25seSB0aGVtZXM6IE5nRG9jVGhlbWVbXSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IHN0b3JlOiBOZ0RvY1N0b3JlU2VydmljZSxcblx0KSB7XG5cdFx0YWZ0ZXJOZXh0UmVuZGVyKCgpID0+IHtcblx0XHRcdGZyb21FdmVudDxNZWRpYVF1ZXJ5TGlzdD4odGhpcy53aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpLCAnY2hhbmdlJylcblx0XHRcdFx0LnBpcGUodW50aWxEZXN0cm95ZWQodGhpcykpXG5cdFx0XHRcdC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRBdXRvVGhlbWUoKSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCB0aGVtZS5cblx0ICovXG5cdGdldCBjdXJyZW50VGhlbWUoKTogTmdEb2NUaGVtZSB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMudGhlbWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIGF1dG9tYXRpYyB0aGVtZSBzd2l0Y2hpbmcgYmFzZWQgb24gdGhlIHVzZXIncyBvcGVyYXRpbmcgc3lzdGVtIHNldHRpbmdzIGlzIGVuYWJsZWQuXG5cdCAqL1xuXHRnZXQgaXNBdXRvVGhlbWVFbmFibGVkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmF1dG9UaGVtZSAhPT0gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgYXV0b21hdGljIHRoZW1lIHN3aXRjaGluZyBiYXNlZCBvbiB0aGUgdXNlcidzIG9wZXJhdGluZyBzeXN0ZW0gc2V0dGluZ3MuXG5cdCAqIEBwYXJhbSBsaWdodCAtIFRoZW1lIGZvciBsaWdodCBtb2RlLlxuXHQgKiBAcGFyYW0gZGFyayAtIFRoZW1lIGZvciBkYXJrIG1vZGUuXG5cdCAqL1xuXHRhc3luYyBlbmFibGVBdXRvVGhlbWUoXG5cdFx0bGlnaHQ6IE5nRG9jVGhlbWUgfCB1bmRlZmluZWQsXG5cdFx0ZGFyazogTmdEb2NUaGVtZSB8IHVuZGVmaW5lZCxcblx0KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGhpcy5hdXRvVGhlbWUgPSBbbGlnaHQsIGRhcmtdO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0QXV0b1RoZW1lKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgYXV0b21hdGljIHRoZW1lIHN3aXRjaGluZyBiYXNlZCBvbiB0aGUgdXNlcidzIG9wZXJhdGluZyBzeXN0ZW0gc2V0dGluZ3MuXG5cdCAqL1xuXHRhc3luYyBkaXNhYmxlQXV0b1RoZW1lKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMuYXV0b1RoZW1lID0gdW5kZWZpbmVkO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KHRoaXMuc3RvcmUuZ2V0KE5HX0RPQ19TVE9SRV9USEVNRV9LRVkpID8/IHVuZGVmaW5lZCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdGhlbWUgYnkgaWQuXG5cdCAqIEBwYXJhbSBpZCAtIFRoZW1lIGlkLlxuXHQgKiBAcGFyYW0gc2F2ZSAtIFdoZXRoZXIgdG8gc2F2ZSB0aGUgdGhlbWUgaW4gdGhlIHN0b3JlIHRvIHJlc3RvcmUgaXQgd2hlbiB0aGUgcGFnZSBpcyByZWxvYWRlZC4gKGB0cnVlYCBieSBkZWZhdWx0KVxuXHQgKi9cblx0YXN5bmMgc2V0KGlkPzogc3RyaW5nLCBzYXZlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMucmVtb3ZlTGluaygpO1xuXG5cdFx0aWYgKHNhdmUpIHtcblx0XHRcdHRoaXMuYXV0b1RoZW1lID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmIChpZCAmJiBpZCAhPT0gJ25nLWRvYy1kYXknKSB7XG5cdFx0XHRjb25zdCB0aGVtZTogTmdEb2NUaGVtZSB8IHVuZGVmaW5lZCA9IHRoaXMudGhlbWVzLmZpbmQoXG5cdFx0XHRcdCh0aGVtZTogTmdEb2NUaGVtZSkgPT4gdGhlbWUuaWQgPT09IGlkLFxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCF0aGVtZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0YFRoZW1lIHdpdGggaWQgXCIke2lkfVwiIGlzIG5vdCByZWdpc3RlcmVkLiBNYWtlIHN1cmUgdGhhdCB5b3UgcmVnaXN0ZXJlZCBpdCBpbiB0aGUgcm9vdCBvZiB5b3VyIGFwcGxpY2F0aW9uLmAsXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNyZWF0ZUxpbmtJZk5vRXhpc3RzKCk7XG5cblx0XHRcdGlmICh0aGlzLmxpbmtFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMubGlua0VsZW1lbnQuaHJlZiA9IHRoZW1lLnBhdGg7XG5cdFx0XHRcdHNhdmUgJiYgdGhpcy5zdG9yZS5zZXQoTkdfRE9DX1NUT1JFX1RIRU1FX0tFWSwgdGhlbWUuaWQpO1xuXHRcdFx0XHR0aGlzLnRoZW1lID0gdGhlbWU7XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlOiAoKSA9PiB2b2lkLCByZWplY3Q6IChlcnI6IEV2ZW50IHwgc3RyaW5nKSA9PiB2b2lkKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHRoaXMubGlua0VsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHRoaXMubGlua0VsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRoZW1lJC5uZXh0KHRoZW1lKTtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHRoaXMubGlua0VsZW1lbnQub25lcnJvciA9IHJlamVjdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzYXZlICYmIHRoaXMuc3RvcmUuc2V0KE5HX0RPQ19TVE9SRV9USEVNRV9LRVksICduZy1kb2MtZGF5Jyk7XG5cblx0XHR0aGlzLnRoZW1lJC5uZXh0KHVuZGVmaW5lZCk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgdGhlbWUgY2hhbmdlcy5cblx0ICovXG5cdHRoZW1lQ2hhbmdlcygpOiBPYnNlcnZhYmxlPE5nRG9jVGhlbWUgfCB1bmRlZmluZWQ+IHtcblx0XHRyZXR1cm4gdGhpcy50aGVtZSQuYXNPYnNlcnZhYmxlKCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUxpbmsoKTogdm9pZCB7XG5cdFx0dGhpcy50aGVtZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmxpbmtFbGVtZW50Py5yZW1vdmUoKTtcblx0XHR0aGlzLmxpbmtFbGVtZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0cHJpdmF0ZSBjcmVhdGVMaW5rSWZOb0V4aXN0cygpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMubGlua0VsZW1lbnQpIHtcblx0XHRcdHRoaXMubGlua0VsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblx0XHRcdHRoaXMubGlua0VsZW1lbnQuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuXHRcdFx0dGhpcy5saW5rRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZCh0aGlzLmxpbmtFbGVtZW50KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHNldEF1dG9UaGVtZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAodGhpcy5hdXRvVGhlbWUgIT09IHVuZGVmaW5lZCAmJiBpc0Jyb3dzZXIpIHtcblx0XHRcdGNvbnN0IGlzRGFyazogYm9vbGVhbiA9IHRoaXMud2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzO1xuXHRcdFx0Y29uc3QgW2xpZ2h0LCBkYXJrXSA9IHRoaXMuYXV0b1RoZW1lO1xuXHRcdFx0dGhpcy5zdG9yZS5zZXQoTkdfRE9DX1NUT1JFX1RIRU1FX0tFWSwgTmdEb2NUaGVtZVNlcnZpY2UuYXV0b1RoZW1lSWQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoaXNEYXJrID8gZGFyaz8uaWQgOiBsaWdodD8uaWQsIGZhbHNlKTtcblx0XHR9XG5cdH1cbn1cbiJdfQ==