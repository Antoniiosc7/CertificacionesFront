import { __decorate, __metadata } from "tslib";
import { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable } from '@angular/core';
import { NavigationEnd, Router } from '@angular/router';
import { NgDocScrollService } from '@ng-doc/ui-kit/services/scroll';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { debounceTime, distinctUntilChanged, filter, pluck } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/layout";
import * as i2 from "@angular/router";
import * as i3 from "@ng-doc/ui-kit/services/scroll";
/**
 * Service for sidebar, it can be used to hide/show sidebar or to check if sidebar is collapsable.
 */
let NgDocSidebarService = class NgDocSidebarService {
    constructor(document, breakpointObserver, router, scroll) {
        this.document = document;
        this.breakpointObserver = breakpointObserver;
        this.router = router;
        this.scroll = scroll;
        this.breakpoints = [Breakpoints.XSmall, Breakpoints.Small];
        this.expanded = new BehaviorSubject(true);
        this.observer = this.breakpointObserver
            .observe(this.breakpoints)
            .pipe(pluck('matches'), distinctUntilChanged(), untilDestroyed(this));
        combineLatest([this.router.events, this.isMobileMode()])
            .pipe(filter(([event, isMobileMode]) => event instanceof NavigationEnd && this.expanded.value && isMobileMode), debounceTime(10))
            .subscribe(() => this.hide());
        this.isMobileMode()
            .pipe(untilDestroyed(this))
            .subscribe((isMobileMode) => {
            if (isMobileMode) {
                this.hide();
            }
            else {
                this.show();
                this.scroll.unblock();
            }
        });
    }
    /**
     * Indicates if sidebar is collapsable, based on the screen size.
     */
    isMobileMode() {
        return this.observer;
    }
    /**
     * Indicates if sidebar is visible, based on the show/hide methods.
     */
    isExpanded() {
        return this.expanded.asObservable();
    }
    /**
     * Show sidebar, and block scrolling.
     */
    show() {
        if (!this.expanded.value) {
            this.expanded.next(true);
            this.scroll.block();
        }
    }
    /**
     * Hide sidebar, and unblock scrolling.
     */
    hide() {
        if (this.expanded.value) {
            this.expanded.next(false);
            this.scroll.unblock();
        }
    }
    /**
     * Toggle sidebar visibility.
     */
    toggle() {
        this.expanded.value ? this.hide() : this.show();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocSidebarService, deps: [{ token: DOCUMENT }, { token: i1.BreakpointObserver }, { token: i2.Router }, { token: i3.NgDocScrollService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocSidebarService, providedIn: 'root' }); }
};
NgDocSidebarService = __decorate([
    UntilDestroy(),
    __metadata("design:paramtypes", [Document,
        BreakpointObserver,
        Router,
        NgDocScrollService])
], NgDocSidebarService);
export { NgDocSidebarService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: NgDocSidebarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.BreakpointObserver }, { type: i2.Router }, { type: i3.NgDocScrollService }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lkZWJhci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9hcHAvc2VydmljZXMvc2lkZWJhci9zaWRlYmFyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxXQUFXLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFRLGFBQWEsRUFBRSxNQUFNLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3RCxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNsRSxPQUFPLEVBQUMsWUFBWSxFQUFFLGNBQWMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ25FLE9BQU8sRUFBQyxlQUFlLEVBQUUsYUFBYSxFQUFhLE1BQU0sTUFBTSxDQUFDO0FBQ2hFLE9BQU8sRUFBQyxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7OztBQUVqRjs7R0FFRztBQUtJLElBQU0sbUJBQW1CLEdBQXpCLE1BQU0sbUJBQW1CO0lBSy9CLFlBRW9CLFFBQWtCLEVBQ2xCLGtCQUFzQyxFQUN0QyxNQUFjLEVBQ2QsTUFBMEI7UUFIMUIsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO1FBQ3RDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxXQUFNLEdBQU4sTUFBTSxDQUFvQjtRQVRyQyxnQkFBVyxHQUFhLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdEQsYUFBUSxHQUE2QixJQUFJLGVBQWUsQ0FBVSxJQUFJLENBQUMsQ0FBQztRQVMxRixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0I7YUFDckMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7YUFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxvQkFBb0IsRUFBRSxFQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXZFLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO2FBQ3RELElBQUksQ0FDSixNQUFNLENBQ0wsQ0FBQyxDQUFDLEtBQUssRUFBRSxZQUFZLENBQW1CLEVBQUUsRUFBRSxDQUMzQyxLQUFLLFlBQVksYUFBYSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxJQUFJLFlBQVksQ0FDdEUsRUFDRCxZQUFZLENBQUMsRUFBRSxDQUFDLENBQ2hCO2FBQ0EsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRS9CLElBQUksQ0FBQyxZQUFZLEVBQUU7YUFDakIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMxQixTQUFTLENBQUMsQ0FBQyxZQUFxQixFQUFFLEVBQUU7WUFDcEMsSUFBSSxZQUFZLEVBQUUsQ0FBQztnQkFDbEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2IsQ0FBQztpQkFBTSxDQUFDO2dCQUNQLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDWixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3ZCLENBQUM7UUFDRixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVk7UUFDWCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNULE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJO1FBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDMUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNyQixDQUFDO0lBQ0YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSTtRQUNILElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3ZCLENBQUM7SUFDRixDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNO1FBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2pELENBQUM7OEdBN0VXLG1CQUFtQixrQkFNdEIsUUFBUTtrSEFOTCxtQkFBbUIsY0FIbkIsTUFBTTs7QUFHTixtQkFBbUI7SUFEL0IsWUFBWSxFQUFFO3FDQVFnQixRQUFRO1FBQ0Usa0JBQWtCO1FBQzlCLE1BQU07UUFDTixrQkFBa0I7R0FWbEMsbUJBQW1CLENBOEUvQjs7MkZBOUVZLG1CQUFtQjtrQkFKL0IsVUFBVTttQkFBQztvQkFDWCxVQUFVLEVBQUUsTUFBTTtpQkFDbEI7OzBCQVFFLE1BQU07MkJBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QnJlYWtwb2ludE9ic2VydmVyLCBCcmVha3BvaW50c30gZnJvbSAnQGFuZ3VsYXIvY2RrL2xheW91dCc7XG5pbXBvcnQge0RPQ1VNRU5UfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFdmVudCwgTmF2aWdhdGlvbkVuZCwgUm91dGVyfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHtOZ0RvY1Njcm9sbFNlcnZpY2V9IGZyb20gJ0BuZy1kb2MvdWkta2l0L3NlcnZpY2VzL3Njcm9sbCc7XG5pbXBvcnQge1VudGlsRGVzdHJveSwgdW50aWxEZXN0cm95ZWR9IGZyb20gJ0BuZ25lYXQvdW50aWwtZGVzdHJveSc7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2RlYm91bmNlVGltZSwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgcGx1Y2t9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBzaWRlYmFyLCBpdCBjYW4gYmUgdXNlZCB0byBoaWRlL3Nob3cgc2lkZWJhciBvciB0byBjaGVjayBpZiBzaWRlYmFyIGlzIGNvbGxhcHNhYmxlLlxuICovXG5ASW5qZWN0YWJsZSh7XG5cdHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5AVW50aWxEZXN0cm95KClcbmV4cG9ydCBjbGFzcyBOZ0RvY1NpZGViYXJTZXJ2aWNlIHtcblx0cmVhZG9ubHkgYnJlYWtwb2ludHM6IHN0cmluZ1tdID0gW0JyZWFrcG9pbnRzLlhTbWFsbCwgQnJlYWtwb2ludHMuU21hbGxdO1xuXHRwcm90ZWN0ZWQgcmVhZG9ubHkgb2JzZXJ2ZXI6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cdHByb3RlY3RlZCByZWFkb25seSBleHBhbmRlZDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0cnVlKTtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRASW5qZWN0KERPQ1VNRU5UKVxuXHRcdHByb3RlY3RlZCByZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXG5cdFx0cHJvdGVjdGVkIHJlYWRvbmx5IGJyZWFrcG9pbnRPYnNlcnZlcjogQnJlYWtwb2ludE9ic2VydmVyLFxuXHRcdHByb3RlY3RlZCByZWFkb25seSByb3V0ZXI6IFJvdXRlcixcblx0XHRwcm90ZWN0ZWQgcmVhZG9ubHkgc2Nyb2xsOiBOZ0RvY1Njcm9sbFNlcnZpY2UsXG5cdCkge1xuXHRcdHRoaXMub2JzZXJ2ZXIgPSB0aGlzLmJyZWFrcG9pbnRPYnNlcnZlclxuXHRcdFx0Lm9ic2VydmUodGhpcy5icmVha3BvaW50cylcblx0XHRcdC5waXBlKHBsdWNrKCdtYXRjaGVzJyksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHVudGlsRGVzdHJveWVkKHRoaXMpKTtcblxuXHRcdGNvbWJpbmVMYXRlc3QoW3RoaXMucm91dGVyLmV2ZW50cywgdGhpcy5pc01vYmlsZU1vZGUoKV0pXG5cdFx0XHQucGlwZShcblx0XHRcdFx0ZmlsdGVyKFxuXHRcdFx0XHRcdChbZXZlbnQsIGlzTW9iaWxlTW9kZV06IFtFdmVudCwgYm9vbGVhbl0pID0+XG5cdFx0XHRcdFx0XHRldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQgJiYgdGhpcy5leHBhbmRlZC52YWx1ZSAmJiBpc01vYmlsZU1vZGUsXG5cdFx0XHRcdCksXG5cdFx0XHRcdGRlYm91bmNlVGltZSgxMCksXG5cdFx0XHQpXG5cdFx0XHQuc3Vic2NyaWJlKCgpID0+IHRoaXMuaGlkZSgpKTtcblxuXHRcdHRoaXMuaXNNb2JpbGVNb2RlKClcblx0XHRcdC5waXBlKHVudGlsRGVzdHJveWVkKHRoaXMpKVxuXHRcdFx0LnN1YnNjcmliZSgoaXNNb2JpbGVNb2RlOiBib29sZWFuKSA9PiB7XG5cdFx0XHRcdGlmIChpc01vYmlsZU1vZGUpIHtcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNob3coKTtcblx0XHRcdFx0XHR0aGlzLnNjcm9sbC51bmJsb2NrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyBpZiBzaWRlYmFyIGlzIGNvbGxhcHNhYmxlLCBiYXNlZCBvbiB0aGUgc2NyZWVuIHNpemUuXG5cdCAqL1xuXHRpc01vYmlsZU1vZGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cdFx0cmV0dXJuIHRoaXMub2JzZXJ2ZXI7XG5cdH1cblxuXHQvKipcblx0ICogSW5kaWNhdGVzIGlmIHNpZGViYXIgaXMgdmlzaWJsZSwgYmFzZWQgb24gdGhlIHNob3cvaGlkZSBtZXRob2RzLlxuXHQgKi9cblx0aXNFeHBhbmRlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmRlZC5hc09ic2VydmFibGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaG93IHNpZGViYXIsIGFuZCBibG9jayBzY3JvbGxpbmcuXG5cdCAqL1xuXHRzaG93KCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5leHBhbmRlZC52YWx1ZSkge1xuXHRcdFx0dGhpcy5leHBhbmRlZC5uZXh0KHRydWUpO1xuXHRcdFx0dGhpcy5zY3JvbGwuYmxvY2soKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGlkZSBzaWRlYmFyLCBhbmQgdW5ibG9jayBzY3JvbGxpbmcuXG5cdCAqL1xuXHRoaWRlKCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLmV4cGFuZGVkLnZhbHVlKSB7XG5cdFx0XHR0aGlzLmV4cGFuZGVkLm5leHQoZmFsc2UpO1xuXHRcdFx0dGhpcy5zY3JvbGwudW5ibG9jaygpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgc2lkZWJhciB2aXNpYmlsaXR5LlxuXHQgKi9cblx0dG9nZ2xlKCk6IHZvaWQge1xuXHRcdHRoaXMuZXhwYW5kZWQudmFsdWUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuXHR9XG59XG4iXX0=