"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildNgDoc = buildNgDoc;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const helpers_1 = require("../helpers");
const operators_2 = require("../operators");
const builder_operators_1 = require("./builder-operators");
const dependency_changes_1 = require("./builder-operators/dependency-changes");
const post_build_1 = require("./builder-operators/post-build");
const post_process_1 = require("./builder-operators/post-process");
const print_output_1 = require("./builder-operators/print-output");
const task_1 = require("./builder-operators/task");
const to_builder_output_1 = require("./builder-operators/to-builder-output");
const entities_1 = require("./entities");
const cache_1 = require("./entities/cache");
const indexes_entity_1 = require("./entities/indexes.entity");
const entity_emitter_1 = require("./entity-emitter");
const entity_store_1 = require("./entity-store");
const functions_1 = require("./functions");
const variables_1 = require("./variables");
const watcher_1 = require("./watcher");
/**
 * Builds the documentation and emits files to the file system,
 * based on the changes in the source files.
 * @param context - The builder context.
 */
function buildNgDoc(context) {
    var _a, _b;
    (0, helpers_1.printProgress)('Initializing...');
    // Set global variables
    variables_1.GLOBALS.workspaceRoot = context.context.workspaceRoot;
    const store = new entity_store_1.NgDocEntityStore(context.config);
    const cache = new cache_1.NgDocCache(!!((_a = context.config) === null || _a === void 0 ? void 0 : _a.cache));
    const project = (0, helpers_1.createProject)({ tsConfigFilePath: context.tsConfig });
    // Global entities that should be built after each build cycle
    const globalEntities = [
        new entities_1.NgDocContextEntity(store, cache, context),
        new entities_1.NgDocIndexFileEntity(store, cache, context),
        new entities_1.NgDocRoutesEntity(store, cache, context),
    ];
    const indexesEntity = new indexes_entity_1.NgDocIndexesEntity(store, cache, context);
    const keywordEntity = new entities_1.NgDocKeywordsEntity(store, cache, context);
    // Clean build path if cache is not enabled
    if (!!((_b = context.config) === null || _b === void 0 ? void 0 : _b.cache) && (0, cache_1.invalidateCacheIfNeeded)(context.cachedFiles)) {
        // do nothing
    }
    else {
        fs.rmSync(context.buildPath, { recursive: true, force: true });
    }
    // Watch for changes in pages
    const watcher = new watcher_1.NgDocWatcher(context.pagesPaths
        .map((pagesPath) => [
        path.join(pagesPath, variables_1.PAGE_PATTERN),
        path.join(pagesPath, variables_1.CATEGORY_PATTERN),
        path.join(pagesPath, variables_1.API_PATTERN),
    ])
        .flat());
    // The main build cycle
    return (0, entity_emitter_1.entityEmitter)(store, cache, context, project, watcher).pipe((0, rxjs_1.combineLatestWith)((0, rxjs_1.from)(store.loadGlobalKeywords())), (0, operators_1.map)(([entities]) => entities), (0, rxjs_1.mergeMap)((entities) => (0, rxjs_1.of)(entities).pipe((0, task_1.task)('Updating source files...', (0, builder_operators_1.refresh)()), (0, task_1.taskForMany)('Collecting affected files...', (0, builder_operators_1.addBuildCandidates)(store)), (0, task_1.task)('Compiling...', (0, builder_operators_1.compile)()), (0, task_1.task)('Loading...', (0, builder_operators_1.load)()), (0, dependency_changes_1.dependencyChanges)(watcher), (0, operators_1.tap)(() => store.updateKeywordMap()), (0, task_1.taskForMany)('Building...', (0, builder_operators_1.build)(store, ...globalEntities), (0, functions_1.ifNotCachedOrInvalid)(cache, store)), (0, task_1.taskForMany)('Post-build...', (0, post_build_1.postBuild)()), (0, task_1.taskForMany)('Post-processing...', (0, post_process_1.postProcess)(store, context.config, indexesEntity, keywordEntity)), (0, task_1.taskForMany)(undefined, (0, to_builder_output_1.toBuilderOutput)()), (0, task_1.taskForMany)('Emitting...', (0, builder_operators_1.emit)()), (0, builder_operators_1.collectGarbage)(store))), (0, builder_operators_1.updateCache)(store), (0, print_output_1.printOutput)(store), (0, operators_1.map)(() => void 0), (0, rxjs_1.finalize)(() => watcher.close()), (0, operators_2.progress)());
}
//# sourceMappingURL=build-ng-doc.js.map