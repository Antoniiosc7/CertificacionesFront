"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgDocEntity = void 0;
const tslib_1 = require("tslib");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const classes_1 = require("../../../classes");
const decorators_1 = require("../cache/decorators");
/**
 * Base entity class that all entities should extend.
 */
let NgDocEntity = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _indexes_decorators;
    let _indexes_initializers = [];
    let _indexes_extraInitializers = [];
    let _usedKeywords_decorators;
    let _usedKeywords_initializers = [];
    let _usedKeywords_extraInitializers = [];
    let _potentialKeywords_decorators;
    let _potentialKeywords_initializers = [];
    let _potentialKeywords_extraInitializers = [];
    let _dependencies_decorators;
    let _dependencies_initializers = [];
    let _dependencies_extraInitializers = [];
    let _get_cachedFilePaths_decorators;
    return _a = class NgDocEntity {
            constructor(store, cache, context) {
                this.store = (tslib_1.__runInitializers(this, _instanceExtraInitializers), store);
                this.cache = cache;
                this.context = context;
                /** Indicates when entity was destroyed */
                this.destroyed = false;
                /** Search indexes for the current entity */
                this.indexes = tslib_1.__runInitializers(this, _indexes_initializers, []);
                /**
                 * List of keywords that were linked to the entity
                 */
                this.usedKeywords = (tslib_1.__runInitializers(this, _indexes_extraInitializers), tslib_1.__runInitializers(this, _usedKeywords_initializers, new Set()));
                /**
                 * List of potential keywords that are used by the entity but not linked yet
                 * (they will be sat by Keywords Processor, and used to indicate when this entity should be re-build if one of them appears)
                 */
                this.potentialKeywords = (tslib_1.__runInitializers(this, _usedKeywords_extraInitializers), tslib_1.__runInitializers(this, _potentialKeywords_initializers, new Set()));
                /**
                 * Collection of all file dependencies of the current entity.
                 * This property is using to watch for changes in this dependencies list and rebuild current buildable.
                 */
                this.dependencies = (tslib_1.__runInitializers(this, _potentialKeywords_extraInitializers), tslib_1.__runInitializers(this, _dependencies_initializers, new classes_1.ObservableSet()));
                /**
                 * Indicates if this entity has physical file in file system
                 * If this entity was generated by another Entity, this property should be `false`
                 *
                 * NgDoc destroys all child elements of non-physical entities when they are destroyed
                 */
                this.physical = (tslib_1.__runInitializers(this, _dependencies_extraInitializers), true);
                /**
                 * List of errors that were occurred during the build process
                 */
                this.errors = [];
                /**
                 * List of warnings that were occurred during the build process
                 */
                this.warnings = [];
                this.destroy$ = new rxjs_1.Subject();
            }
            /** Indicates when current entity could be built */
            get canBeBuilt() {
                return true;
            }
            /**
             * Recursively returns parents for the current entity
             * @type {Array<NgDocEntity>}
             */
            get parentEntities() {
                var _b, _c, _d;
                return [(_b = this.parent) !== null && _b !== void 0 ? _b : [], (_d = (_c = this.parent) === null || _c === void 0 ? void 0 : _c.parentEntities) !== null && _d !== void 0 ? _d : []].flat();
            }
            /**
             * The children of the entity.
             * Contains all children of the current entity.
             */
            get children() {
                return this.store
                    .asArray()
                    .filter((entity) => entity.parent === this && !entity.destroyed);
            }
            /**
             * Returns children that are ready to build or already built
             */
            get builtChildren() {
                return this.children.filter((entity) => entity.isReadyForBuild);
            }
            /**
             * Recursively returns children for the current entity
             * @type {Array<NgDocEntity>}
             */
            get childEntities() {
                return this.children.concat(this.children.map((child) => child.childEntities).flat());
            }
            /**
             * Returns `true` if current entity has children
             * @type {boolean}
             */
            get hasChildren() {
                return this.children.length > 0;
            }
            /**
             * Should return if this entity is ready to build
             * @type {boolean}
             */
            get isReadyForBuild() {
                return !this.destroyed && !this.errors.length && this.canBeBuilt;
            }
            get logger() {
                return this.context.context.logger;
            }
            get cachedFilePaths() {
                return this.rootFiles.concat(this.dependencies.asArray());
            }
            /**
             * Method called by NgDocBuilder when one or more dependencies have changed
             */
            dependenciesChanged() {
                // Reset error and warnings, because dependency changes could fix them
                this.warnings = [];
                this.errors = [];
            }
            childrenGenerator() {
                return (0, rxjs_1.of)([]);
            }
            beforeBuild() {
                // Clear all indexes and used keywords before build
                this.usedKeywords.clear();
                this.potentialKeywords.clear();
                this.indexes = [];
            }
            updateCache() {
                if (this.isReadyForBuild && !this.warnings.length) {
                    this.cache.cache(this);
                }
            }
            removeArtifacts() {
                // No implementation
            }
            /**
             * Destroys current entity and clear all references
             * @type {void}
             */
            destroy() {
                this.children.forEach((entity) => !entity.physical && entity.destroy());
                this.destroyed = true;
                this.destroy$.next();
            }
            onDestroy() {
                return this.destroy$.asObservable().pipe((0, operators_1.take)(1));
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _indexes_decorators = [(0, decorators_1.CachedProperty)()];
            _usedKeywords_decorators = [(0, decorators_1.CachedProperty)({
                    get: (value) => new Set(value),
                    set: (value) => Array.from(value),
                })];
            _potentialKeywords_decorators = [(0, decorators_1.CachedProperty)({
                    get: (value) => new Set(value),
                    set: (value) => Array.from(value),
                })];
            _dependencies_decorators = [(0, decorators_1.CachedProperty)({
                    get: (value) => new classes_1.ObservableSet(value),
                    set: (value) => value.asArray(),
                })];
            _get_cachedFilePaths_decorators = [(0, decorators_1.CachedFilesGetter)()];
            tslib_1.__esDecorate(_a, null, _get_cachedFilePaths_decorators, { kind: "getter", name: "cachedFilePaths", static: false, private: false, access: { has: obj => "cachedFilePaths" in obj, get: obj => obj.cachedFilePaths }, metadata: _metadata }, null, _instanceExtraInitializers);
            tslib_1.__esDecorate(null, null, _indexes_decorators, { kind: "field", name: "indexes", static: false, private: false, access: { has: obj => "indexes" in obj, get: obj => obj.indexes, set: (obj, value) => { obj.indexes = value; } }, metadata: _metadata }, _indexes_initializers, _indexes_extraInitializers);
            tslib_1.__esDecorate(null, null, _usedKeywords_decorators, { kind: "field", name: "usedKeywords", static: false, private: false, access: { has: obj => "usedKeywords" in obj, get: obj => obj.usedKeywords, set: (obj, value) => { obj.usedKeywords = value; } }, metadata: _metadata }, _usedKeywords_initializers, _usedKeywords_extraInitializers);
            tslib_1.__esDecorate(null, null, _potentialKeywords_decorators, { kind: "field", name: "potentialKeywords", static: false, private: false, access: { has: obj => "potentialKeywords" in obj, get: obj => obj.potentialKeywords, set: (obj, value) => { obj.potentialKeywords = value; } }, metadata: _metadata }, _potentialKeywords_initializers, _potentialKeywords_extraInitializers);
            tslib_1.__esDecorate(null, null, _dependencies_decorators, { kind: "field", name: "dependencies", static: false, private: false, access: { has: obj => "dependencies" in obj, get: obj => obj.dependencies, set: (obj, value) => { obj.dependencies = value; } }, metadata: _metadata }, _dependencies_initializers, _dependencies_extraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.NgDocEntity = NgDocEntity;
//# sourceMappingURL=entity.js.map