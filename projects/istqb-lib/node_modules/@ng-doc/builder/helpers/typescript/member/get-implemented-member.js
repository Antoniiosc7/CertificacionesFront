"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImplementedMember = getImplementedMember;
const core_1 = require("@ng-doc/core");
const ts_morph_1 = require("ts-morph");
const find_member_1 = require("./find-member");
const get_member_parent_1 = require("./get-member-parent");
/**
 *    Returns member that was implemented by the provided one
 * @param member - Target member
 */
function getImplementedMember(member) {
    const parent = (0, get_member_parent_1.getMemberParent)(member);
    const name = member.getName();
    if (ts_morph_1.Node.isClassDeclaration(parent)) {
        const baseClass = parent.getBaseClass();
        if (baseClass) {
            const member = (0, find_member_1.findMember)(baseClass, name);
            if (ts_morph_1.Node.isAbstractable(member) && member.isAbstract()) {
                return member;
            }
        }
        const nodes = parent
            .getImplements()
            .map((expr) => { var _a; return (_a = expr.getType().getSymbol()) === null || _a === void 0 ? void 0 : _a.getDeclarations()[0]; })
            .filter(core_1.isPresent)
            // Reverse implements because the latest one overrides previous one
            .reverse();
        for (const node of nodes) {
            if (ts_morph_1.Node.isClassDeclaration(node)) {
                const member = (0, find_member_1.findMember)(node, name);
                if (ts_morph_1.Node.isAbstractable(member) && member.isAbstract()) {
                    return member;
                }
            }
            if (ts_morph_1.Node.isInterfaceDeclaration(node)) {
                const member = (0, find_member_1.findMember)(node, name);
                if (member) {
                    return member;
                }
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=get-implemented-member.js.map