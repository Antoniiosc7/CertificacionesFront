"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPlaygroundMetadata = buildPlaygroundMetadata;
const core_1 = require("@ng-doc/core");
const angular_1 = require("../angular");
const extract_selectors_1 = require("../extract-selectors");
const get_content_for_playground_1 = require("./get-content-for-playground");
const get_playground_inputs_1 = require("./get-playground-inputs");
const get_playground_template_inputs_1 = require("./get-playground-template-inputs");
const get_target_for_playground_1 = require("./get-target-for-playground");
const get_template_for_playground_1 = require("./get-template-for-playground");
/**
 * Collects all the information about a playground that is needed to render and build it.
 * @param id - The id of the playground
 * @param playground - The playground object
 * @param additionalProps
 */
function buildPlaygroundMetadata(id, playground, additionalProps) {
    var _a, _b;
    const target = (0, get_target_for_playground_1.getTargetForPlayground)(playground);
    if (!target) {
        throw new Error(`Can't find "target" for playground "${id}"`);
    }
    const decorator = (_b = (_a = (0, angular_1.getComponentDecorator)(target)) !== null && _a !== void 0 ? _a : (0, angular_1.getDirectiveDecorator)(target)) !== null && _b !== void 0 ? _b : (0, angular_1.getPipeDecorator)(target);
    if (!decorator) {
        throw new Error(`Invalid target class for playground "${id}". Make sure that the class is decorated with @Component, @Directive or @Pipe.`);
    }
    const template = (0, get_template_for_playground_1.getTemplateForPlayground)(playground);
    const content = (0, get_content_for_playground_1.getContentForPlayground)(playground);
    const standalone = (0, angular_1.isStandalone)(target);
    if ('selector' in decorator) {
        const selector = decorator.selector.replace(/[\n\s]/gm, '');
        const selectors = (0, extract_selectors_1.extractSelectors)(target);
        const assignedInputs = (0, core_1.getAssignedInputs)(template, selectors);
        const properties = Object.entries(Object.assign(Object.assign({}, (0, get_playground_inputs_1.getPlaygroundComponentInputs)(target)), additionalProps)).reduce((acc, [key, value]) => {
            var _a;
            // Skip the inputs that are already assigned in the template
            if (!assignedInputs.includes((_a = value.inputName) !== null && _a !== void 0 ? _a : key)) {
                return Object.assign(Object.assign({}, acc), { [key]: value });
            }
            return acc;
        }, {});
        const templateInputs = (0, get_playground_template_inputs_1.getPlaygroundTemplateInputs)(properties);
        return {
            selector: selector,
            standalone,
            template,
            templateForComponents: selectors.reduce((templateForComponents, selector) => {
                return Object.assign(Object.assign({}, templateForComponents), { [selector]: (0, core_1.buildPlaygroundDemoTemplate)(template, selector, content, templateInputs, false) });
            }, {}),
            class: target,
            properties,
            content,
        };
    }
    else if ('name' in decorator) {
        const name = decorator.name.replace(/[\n\s]/gm, '');
        const properties = (0, get_playground_inputs_1.getPlaygroundPipeInputs)(target);
        const templateInputs = (0, get_playground_template_inputs_1.getPlaygroundTemplateInputs)(properties);
        return {
            name,
            standalone,
            template,
            templateForComponents: {
                [name]: (0, core_1.buildPlaygroundDemoPipeTemplate)(template, name, content, templateInputs, false),
            },
            class: target,
            properties,
            content,
        };
    }
    else {
        throw new Error(`Invalid target for playground "${id}". Make sure that your @Component/@Directive has a "selector" property or "name" property if you are using @Pipe.`);
    }
}
//# sourceMappingURL=build-playground-metadata.js.map